"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = __importDefault(require("util"));
/**
 * T - Token Types
 * AST - type of returned AST object
 */
function createStringParser(parserName, lexer, grammar) {
    return function (input) {
        const p = parser(parserName, lexer, grammar);
        p.write(input);
        p.end();
        return p.getResult();
    };
}
exports.createStringParser = createStringParser;
/**
 * Help for testing result of lexer function
 * @param lexer
 */
function listTokens(debugName, input, lexer) {
    const lexerLa = new LookAhead(debugName, () => {
        lexerLa._write(input);
        lexerLa._final();
    });
    const tokens = [];
    lexer(lexerLa, {
        emit() {
            const token = strChunk2Token(lexerLa.currChunk);
            token.close(lexerLa.position);
            tokens.push(token);
        },
        end() { }
    });
    return tokens;
}
exports.listTokens = listTokens;
class Chunk {
    constructor(pos, line, col) {
        this.pos = pos;
        this.line = line;
        this.col = col;
        this.values = [];
        this.isClosed = false;
        this.trackValue = true;
    }
    close(position) {
        this.isClosed = true;
        this.end = position;
        return this;
    }
}
exports.Chunk = Chunk;
class Token extends Chunk {
}
exports.Token = Token;
function parser(parserName, lexer, grammar, chunkConverter) {
    let isString;
    const lexerLa = new LookAhead(parserName + ' lexer');
    const tokenEmitter = {
        emit() {
            if (isString === undefined && lexerLa.currChunk.values != null)
                isString = typeof lexerLa.currChunk.values[0] === 'string';
            const token = chunkConverter ? chunkConverter(lexerLa.currChunk) :
                (isString ?
                    strChunk2Token(lexerLa.currChunk) :
                    lexerLa.currChunk);
            tokenLa._write([token]);
            token.close(lexerLa.position);
        },
        end() {
            tokenLa._final();
        }
    };
    const tokenLa = new LookAhead(parserName + ' grammar', function () {
        lexer(lexerLa, tokenEmitter);
    });
    return {
        write: lexerLa._write.bind(lexerLa),
        end: lexerLa._final.bind(lexerLa),
        getResult() {
            return grammar(tokenLa);
        }
    };
}
exports.parser = parser;
class LookAhead {
    constructor(name, onDrain) {
        this.name = name;
        this.onDrain = onDrain;
        this.line = 1;
        this.column = 1;
        this.currPos = 0;
        this.cacheStartPos = 0;
        this.cached = [];
    }
    _write(values) {
        for (const v of values)
            this.cached.push(v);
    }
    _final() {
        this._write([null]);
    }
    get position() {
        return this.currPos;
    }
    /**
       * look ahead for 1 character
       * @param num default is 1
       * @return null if EOF is reached
       */
    la(num = 1) {
        const readPos = this.currPos + num - 1;
        return this.read(readPos);
    }
    advance(count = 1) {
        // return new Promise(resolve => {
        let currValue;
        let i = 0;
        while (i++ < count) {
            const value = this.la(1);
            if (value == null) {
                this.throwError('Unexpect EOF'); // , stack);
                break;
            }
            this.currPos++;
            this.column++;
            if (value === '\n') {
                this.line++;
                this.column = 1;
            }
            if (this.currPos - this.cacheStartPos > 0x100000) {
                this.cached.splice(0, 0x100000);
                this.cacheStartPos += 0x100000;
            }
            if (this.currChunk && !this.currChunk.isClosed && this.currChunk.trackValue) {
                this.currChunk.values.push(value);
            }
            currValue = value;
        }
        this.lastConsumed = currValue;
        return currValue;
    }
    isNext(...values) {
        return this.isNextWith(values);
    }
    /**
       * Same as `return la(1) === values[0] && la(2) === values[1]...`
       * @param values lookahead string or tokens
       */
    isNextWith(values, isEqual = (a, b) => a === b) {
        let compareTo;
        let compareFn;
        compareTo = values;
        compareFn = isEqual;
        let i = 0;
        const l = compareTo.length;
        while (true) {
            if (i === l)
                return true;
            const next = this.la(i + 1);
            if (next == null)
                return false; // EOF
            else if (!compareFn(next, compareTo[i]))
                return false;
            i++;
        }
    }
    assertAdvance(...values) {
        return this.assertAdvanceWith(values);
    }
    assertAdvanceWith(values, isEqual = (a, b) => a === b) {
        let compareTo;
        let compareFn;
        compareTo = values;
        compareFn = isEqual;
        let i = 0;
        const l = compareTo.length;
        while (true) {
            if (i === l)
                return true;
            const next = this.advance(i + 1);
            if (next == null)
                this.throwError('EOF', new Error().stack); // EOF
            else if (!compareFn(next, compareTo[i]))
                this.throwError(util_1.default.inspect(next), new Error().stack, compareTo[i] + '');
            i++;
        }
    }
    throwError(unexpected = 'End-of-stream', stack, expect) {
        // tslint:disable-next-line: max-line-length
        throw new Error(`In ${this.name} unexpected ${JSON.stringify(unexpected)}` +
            (expect ? `(expecting "${expect}")` : '') +
            `at ${this.getCurrentPosInfo()}, ${stack ? 'previous stack:' + stack : ''}`);
    }
    getCurrentPosInfo() {
        return `offset ${this.currPos} [${this.line}:${this.column}]`;
    }
    startChunk(type, trackValue = true) {
        if (this.currChunk && !this.currChunk.isClosed)
            this.currChunk.close(this.currPos);
        this.currChunk = new Chunk(this.currPos, this.line, this.column);
        this.currChunk.trackValue = trackValue;
        this.currChunk.type = type;
        return this.currChunk;
    }
    closeChunk() {
        return this.currChunk.close(this.currPos);
    }
    /**
       * Do not read postion less than 0
       * @param pos
       */
    read(pos) {
        const cacheOffset = pos - this.cacheStartPos;
        if (cacheOffset < 0) {
            throw new Error(`Can not read behind stream cache, at position: ${pos}`);
        }
        while (true) {
            if (cacheOffset < this.cached.length) {
                return this.cached[cacheOffset];
            }
            else {
                if (this.onDrain) {
                    this.onDrain();
                    continue;
                }
                throw new Error(`The internal buffer is drained early at ${pos}`);
                // this.waitForPos = pos;
                // const err = new WaitError();
                // throw err;
                // return new Promise(resolve => {
                //   this.readResolve = resolve;
                // });
            }
        }
    }
}
exports.LookAhead = LookAhead;
function strChunk2Token(chunk) {
    if (chunk.values) {
        chunk.text = chunk.values.join('');
        delete chunk.values;
    }
    return chunk;
}
/**
 * Convenient function for creating a text based parser,
 * you only need to define Token types, lexer function, grammar function
 */
function createTextParser() {
}
exports.createTextParser = createTextParser;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTExuLXBhcnNlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3RzL0xMbi1wYXJzZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxnREFBd0I7QUFFeEI7OztHQUdHO0FBQ0gsU0FBZ0Isa0JBQWtCLENBQVMsVUFBa0IsRUFBRSxLQUF1QixFQUNwRixPQUErQjtJQUUvQixPQUFPLFVBQVMsS0FBYTtRQUMzQixNQUFNLENBQUMsR0FBRyxNQUFNLENBQUMsVUFBVSxFQUFFLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQztRQUM3QyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2YsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ1IsT0FBTyxDQUFDLENBQUMsU0FBUyxFQUFFLENBQUM7SUFDdkIsQ0FBQyxDQUFDO0FBQ0osQ0FBQztBQVRELGdEQVNDO0FBRUQ7OztHQUdHO0FBQ0gsU0FBZ0IsVUFBVSxDQUFJLFNBQWlCLEVBQUUsS0FBYSxFQUFFLEtBQXVCO0lBQ3JGLE1BQU0sT0FBTyxHQUFHLElBQUksU0FBUyxDQUFZLFNBQVMsRUFBRSxHQUFHLEVBQUU7UUFDdkQsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN0QixPQUFPLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDbkIsQ0FBQyxDQUFDLENBQUM7SUFFSCxNQUFNLE1BQU0sR0FBRyxFQUFnQixDQUFDO0lBQ2hDLEtBQUssQ0FBQyxPQUFPLEVBQUU7UUFDYixJQUFJO1lBQ0YsTUFBTSxLQUFLLEdBQUcsY0FBYyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUNoRCxLQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUM5QixNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3JCLENBQUM7UUFDRCxHQUFHLEtBQUksQ0FBQztLQUNULENBQUMsQ0FBQztJQUVILE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUM7QUFqQkQsZ0NBaUJDO0FBQ0QsTUFBYSxLQUFLO0lBT2hCLFlBQ1MsR0FBVyxFQUFTLElBQVksRUFBUyxHQUFXO1FBQXBELFFBQUcsR0FBSCxHQUFHLENBQVE7UUFBUyxTQUFJLEdBQUosSUFBSSxDQUFRO1FBQVMsUUFBRyxHQUFILEdBQUcsQ0FBUTtRQU43RCxXQUFNLEdBQVMsRUFBRSxDQUFDO1FBRWxCLGFBQVEsR0FBRyxLQUFLLENBQUM7UUFDakIsZUFBVSxHQUFHLElBQUksQ0FBQztJQUlmLENBQUM7SUFFSixLQUFLLENBQUMsUUFBZ0I7UUFDcEIsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7UUFDckIsSUFBSSxDQUFDLEdBQUcsR0FBRyxRQUFRLENBQUM7UUFDcEIsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0NBQ0Y7QUFoQkQsc0JBZ0JDO0FBRUQsTUFBYSxLQUFTLFNBQVEsS0FBZ0I7Q0FFN0M7QUFGRCxzQkFFQztBQWdCRCxTQUFnQixNQUFNLENBQWlDLFVBQWtCLEVBQ3ZFLEtBQXFCLEVBQ3JCLE9BQXNCLEVBQ3RCLGNBQTBDO0lBTzFDLElBQUksUUFBaUIsQ0FBQztJQUN0QixNQUFNLE9BQU8sR0FBRyxJQUFJLFNBQVMsQ0FBTyxVQUFVLEdBQUUsUUFBUSxDQUFDLENBQUM7SUFDMUQsTUFBTSxZQUFZLEdBQTBCO1FBQzFDLElBQUk7WUFDRixJQUFJLFFBQVEsS0FBSyxTQUFTLElBQUksT0FBTyxDQUFDLFNBQVMsQ0FBQyxNQUFNLElBQUksSUFBSTtnQkFDNUQsUUFBUSxHQUFHLE9BQU8sT0FBTyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssUUFBUSxDQUFDO1lBQzdELE1BQU0sS0FBSyxHQUFNLGNBQWMsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO2dCQUNuRSxDQUFDLFFBQVEsQ0FBQyxDQUFDO29CQUNULGNBQWMsQ0FBQyxPQUFPLENBQUMsU0FBd0MsQ0FBaUIsQ0FBQyxDQUFDO29CQUNsRixPQUFPLENBQUMsU0FBYyxDQUFDLENBQUM7WUFDNUIsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFDeEIsS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDaEMsQ0FBQztRQUNELEdBQUc7WUFDRCxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDbkIsQ0FBQztLQUNGLENBQUM7SUFDRixNQUFNLE9BQU8sR0FBRyxJQUFJLFNBQVMsQ0FBSSxVQUFVLEdBQUcsVUFBVSxFQUFFO1FBQ3hELEtBQUssQ0FBQyxPQUFPLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDL0IsQ0FBQyxDQUFDLENBQUM7SUFDSCxPQUFPO1FBQ0wsS0FBSyxFQUFFLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQztRQUNuQyxHQUFHLEVBQUUsT0FBTyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDO1FBQ2pDLFNBQVM7WUFDUCxPQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMxQixDQUFDO0tBQ0YsQ0FBQztBQUNKLENBQUM7QUFyQ0Qsd0JBcUNDO0FBR0QsTUFBYSxTQUFTO0lBV3BCLFlBQXNCLElBQVksRUFBVSxPQUF5QztRQUEvRCxTQUFJLEdBQUosSUFBSSxDQUFRO1FBQVUsWUFBTyxHQUFQLE9BQU8sQ0FBa0M7UUFSckYsU0FBSSxHQUFHLENBQUMsQ0FBQztRQUNULFdBQU0sR0FBRyxDQUFDLENBQUM7UUFJSCxZQUFPLEdBQUcsQ0FBQyxDQUFDO1FBQ1osa0JBQWEsR0FBRyxDQUFDLENBQUM7UUFHeEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUM7SUFDbkIsQ0FBQztJQUVELE1BQU0sQ0FBQyxNQUF3QjtRQUM3QixLQUFLLE1BQU0sQ0FBQyxJQUFJLE1BQU07WUFDcEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDeEIsQ0FBQztJQUVELE1BQU07UUFDSixJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUN0QixDQUFDO0lBRUQsSUFBSSxRQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO0lBQ3RCLENBQUM7SUFFRDs7OztTQUlFO0lBQ0YsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDO1FBQ1IsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1FBQ3ZDLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUM1QixDQUFDO0lBRUQsT0FBTyxDQUFDLEtBQUssR0FBRyxDQUFDO1FBQ2Ysa0NBQWtDO1FBQ2xDLElBQUksU0FBWSxDQUFDO1FBQ2pCLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNWLE9BQU8sQ0FBQyxFQUFFLEdBQUcsS0FBSyxFQUFFO1lBQ2xCLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDekIsSUFBSSxLQUFLLElBQUksSUFBSSxFQUFFO2dCQUNqQixJQUFJLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsWUFBWTtnQkFDN0MsTUFBTTthQUNQO1lBQ0QsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ2YsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQ2QsSUFBSyxLQUFhLEtBQUssSUFBSSxFQUFFO2dCQUMzQixJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7Z0JBQ1osSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7YUFDakI7WUFDRCxJQUFJLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLGFBQWEsR0FBRyxRQUFRLEVBQUU7Z0JBQ2hELElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQztnQkFDaEMsSUFBSSxDQUFDLGFBQWEsSUFBSSxRQUFRLENBQUM7YUFDaEM7WUFDRCxJQUFJLElBQUksQ0FBQyxTQUFTLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBRTtnQkFDM0UsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQ3BDO1lBQ0QsU0FBUyxHQUFHLEtBQUssQ0FBQztTQUNuQjtRQUNELElBQUksQ0FBQyxZQUFZLEdBQUcsU0FBVSxDQUFDO1FBQy9CLE9BQU8sU0FBVSxDQUFDO0lBQ3BCLENBQUM7SUFFRCxNQUFNLENBQUMsR0FBRyxNQUFXO1FBQ25CLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNqQyxDQUFDO0lBQ0Q7OztTQUdFO0lBQ0YsVUFBVSxDQUFJLE1BQVcsRUFBRSxVQUFVLENBQUMsQ0FBSSxFQUFFLENBQUksRUFBRSxFQUFFLENBQUMsQ0FBUSxLQUFLLENBQUM7UUFDakUsSUFBSSxTQUFzQixDQUFDO1FBQzNCLElBQUksU0FBcUMsQ0FBQztRQUMxQyxTQUFTLEdBQUcsTUFBTSxDQUFDO1FBQ25CLFNBQVMsR0FBRyxPQUFPLENBQUM7UUFDcEIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1YsTUFBTSxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQztRQUMzQixPQUFPLElBQUksRUFBRTtZQUNYLElBQUksQ0FBQyxLQUFLLENBQUM7Z0JBQ1QsT0FBTyxJQUFJLENBQUM7WUFDZCxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUM1QixJQUFJLElBQUksSUFBSSxJQUFJO2dCQUNkLE9BQU8sS0FBSyxDQUFDLENBQUMsTUFBTTtpQkFDakIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNyQyxPQUFPLEtBQUssQ0FBQztZQUNmLENBQUMsRUFBRSxDQUFDO1NBQ0w7SUFDSCxDQUFDO0lBRUQsYUFBYSxDQUFDLEdBQUcsTUFBVztRQUMxQixPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBRUQsaUJBQWlCLENBQUksTUFBVyxFQUFFLFVBQVUsQ0FBQyxDQUFJLEVBQUUsQ0FBSSxFQUFFLEVBQUUsQ0FBQyxDQUFRLEtBQUssQ0FBQztRQUN4RSxJQUFJLFNBQXNCLENBQUM7UUFDM0IsSUFBSSxTQUFxQyxDQUFDO1FBQzFDLFNBQVMsR0FBRyxNQUFNLENBQUM7UUFDbkIsU0FBUyxHQUFHLE9BQU8sQ0FBQztRQUNwQixJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDVixNQUFNLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxDQUFDO1FBQzNCLE9BQU8sSUFBSSxFQUFFO1lBQ1gsSUFBSSxDQUFDLEtBQUssQ0FBQztnQkFDVCxPQUFPLElBQUksQ0FBQztZQUNkLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ2pDLElBQUksSUFBSSxJQUFJLElBQUk7Z0JBQ2QsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLEVBQUUsSUFBSSxLQUFLLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE1BQU07aUJBQzlDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDckMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxjQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksS0FBSyxFQUFFLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztZQUM1RSxDQUFDLEVBQUUsQ0FBQztTQUNMO0lBQ0gsQ0FBQztJQUVELFVBQVUsQ0FBQyxVQUFVLEdBQUcsZUFBZSxFQUFFLEtBQVcsRUFBRSxNQUFlO1FBQ25FLDRDQUE0QztRQUM1QyxNQUFNLElBQUksS0FBSyxDQUFDLE1BQU0sSUFBSSxDQUFDLElBQUksZUFBZSxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQzFFLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxlQUFlLE1BQU0sSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDekMsTUFBTSxJQUFJLENBQUMsaUJBQWlCLEVBQUUsS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDLGlCQUFpQixHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUMvRSxDQUFDO0lBRUQsaUJBQWlCO1FBQ2YsT0FBTyxVQUFVLElBQUksQ0FBQyxPQUFPLEtBQUssSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUM7SUFDaEUsQ0FBQztJQUVELFVBQVUsQ0FBQyxJQUFPLEVBQUUsVUFBVSxHQUFHLElBQUk7UUFDbkMsSUFBSSxJQUFJLENBQUMsU0FBUyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRO1lBQzVDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNyQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksS0FBSyxDQUFPLElBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDdkUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFDO1FBQ3ZDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUMzQixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUM7SUFDeEIsQ0FBQztJQUVTLFVBQVU7UUFDbEIsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUVEOzs7U0FHRTtJQUNNLElBQUksQ0FBQyxHQUFXO1FBQ3RCLE1BQU0sV0FBVyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDO1FBQzdDLElBQUksV0FBVyxHQUFHLENBQUMsRUFBRTtZQUNuQixNQUFNLElBQUksS0FBSyxDQUFDLGtEQUFrRCxHQUFHLEVBQUUsQ0FBQyxDQUFDO1NBQzFFO1FBQ0QsT0FBTyxJQUFJLEVBQUU7WUFDWCxJQUFJLFdBQVcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRTtnQkFDcEMsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2FBQ2pDO2lCQUFNO2dCQUNMLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRTtvQkFDaEIsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO29CQUNmLFNBQVM7aUJBQ1Y7Z0JBQ0QsTUFBTSxJQUFJLEtBQUssQ0FBQywyQ0FBMkMsR0FBRyxFQUFFLENBQUMsQ0FBQztnQkFDbEUseUJBQXlCO2dCQUN6QiwrQkFBK0I7Z0JBQy9CLGFBQWE7Z0JBQ2Isa0NBQWtDO2dCQUNsQyxnQ0FBZ0M7Z0JBQ2hDLE1BQU07YUFDUDtTQUNGO0lBQ0gsQ0FBQztDQUNGO0FBdktELDhCQXVLQztBQUVELFNBQVMsY0FBYyxDQUFJLEtBQXVCO0lBQ2hELElBQUksS0FBSyxDQUFDLE1BQU0sRUFBRTtRQUNmLEtBQWtCLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ2pELE9BQU8sS0FBSyxDQUFDLE1BQU0sQ0FBQztLQUNyQjtJQUNELE9BQU8sS0FBaUIsQ0FBQztBQUMzQixDQUFDO0FBRUQ7OztHQUdHO0FBQ0gsU0FBZ0IsZ0JBQWdCO0FBRWhDLENBQUM7QUFGRCw0Q0FFQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB1dGlsIGZyb20gJ3V0aWwnO1xuXG4vKipcbiAqIFQgLSBUb2tlbiBUeXBlc1xuICogQVNUIC0gdHlwZSBvZiByZXR1cm5lZCBBU1Qgb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdHJpbmdQYXJzZXI8VCwgQVNUPihwYXJzZXJOYW1lOiBzdHJpbmcsIGxleGVyOiBMZXhlcjxzdHJpbmcsIFQ+LFxuICBncmFtbWFyOiBHcmFtbWFyPFRva2VuPFQ+LCBBU1Q+KSB7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGlucHV0OiBzdHJpbmcpIHtcbiAgICBjb25zdCBwID0gcGFyc2VyKHBhcnNlck5hbWUsIGxleGVyLCBncmFtbWFyKTtcbiAgICBwLndyaXRlKGlucHV0KTtcbiAgICBwLmVuZCgpO1xuICAgIHJldHVybiBwLmdldFJlc3VsdCgpO1xuICB9O1xufVxuXG4vKipcbiAqIEhlbHAgZm9yIHRlc3RpbmcgcmVzdWx0IG9mIGxleGVyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbGV4ZXIgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0VG9rZW5zPFQ+KGRlYnVnTmFtZTogc3RyaW5nLCBpbnB1dDogc3RyaW5nLCBsZXhlcjogTGV4ZXI8c3RyaW5nLCBUPik6IFRva2VuPFQ+W10ge1xuICBjb25zdCBsZXhlckxhID0gbmV3IExvb2tBaGVhZDxzdHJpbmcsIFQ+KGRlYnVnTmFtZSwgKCkgPT4ge1xuICAgIGxleGVyTGEuX3dyaXRlKGlucHV0KTtcbiAgICBsZXhlckxhLl9maW5hbCgpO1xuICB9KTtcblxuICBjb25zdCB0b2tlbnMgPSBbXSBhcyBUb2tlbjxUPltdO1xuICBsZXhlcihsZXhlckxhLCB7XG4gICAgZW1pdCgpIHtcbiAgICAgIGNvbnN0IHRva2VuID0gc3RyQ2h1bmsyVG9rZW4obGV4ZXJMYS5jdXJyQ2h1bmspO1xuICAgICAgdG9rZW4uY2xvc2UobGV4ZXJMYS5wb3NpdGlvbik7XG4gICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgfSxcbiAgICBlbmQoKSB7fVxuICB9KTtcblxuICByZXR1cm4gdG9rZW5zO1xufVxuZXhwb3J0IGNsYXNzIENodW5rPFYsIFQ+IHtcbiAgdHlwZTogVDtcbiAgdmFsdWVzPzogVltdID0gW107XG4gIGVuZDogbnVtYmVyO1xuICBpc0Nsb3NlZCA9IGZhbHNlO1xuICB0cmFja1ZhbHVlID0gdHJ1ZTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgcG9zOiBudW1iZXIsIHB1YmxpYyBsaW5lOiBudW1iZXIsIHB1YmxpYyBjb2w6IG51bWJlclxuICApIHt9XG5cbiAgY2xvc2UocG9zaXRpb246IG51bWJlcikge1xuICAgIHRoaXMuaXNDbG9zZWQgPSB0cnVlO1xuICAgIHRoaXMuZW5kID0gcG9zaXRpb247XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFRva2VuPFQ+IGV4dGVuZHMgQ2h1bms8c3RyaW5nLCBUPiB7XG4gIHRleHQ6IHN0cmluZztcbn1cblxuLyoqXG4gKiAgViBpcyB0eXBlIG9mIGVhY2ggYGNoYXJhY3RlcmAsIGUuZy4gc3RyaW5nLCBudW1iZXJcbiAqICBUIGlzIFRva2VuIFR5cGUsIGUuZy4gc3RyaW5nIG9yIGEgZW51bVxuICogIEMgY291bGQgYmUgb21pdFxuICovXG5leHBvcnQgdHlwZSBMZXhlcjxWLFQsIEMgZXh0ZW5kcyBDaHVuazxWLCBUPiA9IENodW5rPFYsIFQ+PiA9XG4gIChsYTogTG9va0FoZWFkPFYsVD4sIGVtaXR0ZXI6IFRva2VuRW1pdHRlcjxWLCBULCBDPikgPT4gdm9pZDtcbmV4cG9ydCB0eXBlIEdyYW1tYXI8QywgQT4gPSAodG9rZW5MYTogTG9va0FoZWFkPEM+KSA9PiBBO1xuXG5pbnRlcmZhY2UgVG9rZW5FbWl0dGVyPFYsIFQsIEM+IHtcbiAgZW1pdCgpOiB2b2lkO1xuICBlbmQoKTogdm9pZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlcjxWLCBULCBDIGV4dGVuZHMgQ2h1bms8ViwgVD4sIEE+KHBhcnNlck5hbWU6IHN0cmluZyxcbiAgbGV4ZXI6IExleGVyPFYsIFQsIEM+LFxuICBncmFtbWFyOiBHcmFtbWFyPEMsIEE+LFxuICBjaHVua0NvbnZlcnRlcj86IChjaHVuazogQ2h1bms8ViwgVD4pID0+IEMpOlxuICB7XG4gICAgd3JpdGU6IExvb2tBaGVhZDxWLCBUPlsnX3dyaXRlJ107XG4gICAgZW5kOiBMb29rQWhlYWQ8ViwgVD5bJ19maW5hbCddO1xuICAgIGdldFJlc3VsdDogKCkgPT4gQVxuICB9IHtcblxuICBsZXQgaXNTdHJpbmc6IGJvb2xlYW47XG4gIGNvbnN0IGxleGVyTGEgPSBuZXcgTG9va0FoZWFkPFYsIFQ+KHBhcnNlck5hbWUrICcgbGV4ZXInKTtcbiAgY29uc3QgdG9rZW5FbWl0dGVyOiBUb2tlbkVtaXR0ZXI8ViwgVCwgQz4gPSB7XG4gICAgZW1pdCgpIHtcbiAgICAgIGlmIChpc1N0cmluZyA9PT0gdW5kZWZpbmVkICYmIGxleGVyTGEuY3VyckNodW5rLnZhbHVlcyAhPSBudWxsKVxuICAgICAgICBpc1N0cmluZyA9IHR5cGVvZiBsZXhlckxhLmN1cnJDaHVuay52YWx1ZXNbMF0gPT09ICdzdHJpbmcnO1xuICAgICAgY29uc3QgdG9rZW46IEMgPSBjaHVua0NvbnZlcnRlciA/IGNodW5rQ29udmVydGVyKGxleGVyTGEuY3VyckNodW5rKSA6XG4gICAgICAgIChpc1N0cmluZyA/XG4gICAgICAgICAgc3RyQ2h1bmsyVG9rZW4obGV4ZXJMYS5jdXJyQ2h1bmsgYXMgdW5rbm93biBhcyBDaHVuazxzdHJpbmcsIFQ+KSBhcyB1bmtub3duIGFzIEMgOlxuICAgICAgICAgIGxleGVyTGEuY3VyckNodW5rIGFzIEMpO1xuICAgICAgdG9rZW5MYS5fd3JpdGUoW3Rva2VuXSk7XG4gICAgICB0b2tlbi5jbG9zZShsZXhlckxhLnBvc2l0aW9uKTtcbiAgICB9LFxuICAgIGVuZCgpIHtcbiAgICAgIHRva2VuTGEuX2ZpbmFsKCk7XG4gICAgfVxuICB9O1xuICBjb25zdCB0b2tlbkxhID0gbmV3IExvb2tBaGVhZDxDPihwYXJzZXJOYW1lICsgJyBncmFtbWFyJywgZnVuY3Rpb24oKSB7XG4gICAgbGV4ZXIobGV4ZXJMYSwgdG9rZW5FbWl0dGVyKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgd3JpdGU6IGxleGVyTGEuX3dyaXRlLmJpbmQobGV4ZXJMYSksXG4gICAgZW5kOiBsZXhlckxhLl9maW5hbC5iaW5kKGxleGVyTGEpLFxuICAgIGdldFJlc3VsdCgpIHtcbiAgICAgIHJldHVybiBncmFtbWFyKHRva2VuTGEpO1xuICAgIH1cbiAgfTtcbn1cblxuXG5leHBvcnQgY2xhc3MgTG9va0FoZWFkPFYsIFQgPSB2b2lkPiB7XG4gIHN0YXRpYyBXQUlUX0VSUk9SOiAnV0FJVF9FUlJPUic7XG4gIGNhY2hlZDogQXJyYXk8VnxudWxsPjtcbiAgbGluZSA9IDE7XG4gIGNvbHVtbiA9IDE7XG4gIGxhc3RDb25zdW1lZDogVjtcbiAgY3VyckNodW5rOiBDaHVuazxWLCBUPjtcblxuICBwcml2YXRlIGN1cnJQb3MgPSAwO1xuICBwcml2YXRlIGNhY2hlU3RhcnRQb3MgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBuYW1lOiBzdHJpbmcsIHByaXZhdGUgb25EcmFpbj86ICh0aGlzOiBMb29rQWhlYWQ8ViwgVD4pID0+IHZvaWQpIHtcbiAgICB0aGlzLmNhY2hlZCA9IFtdO1xuICB9XG5cbiAgX3dyaXRlKHZhbHVlczogSXRlcmFibGU8VnxudWxsPikge1xuICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZXMpXG4gICAgICB0aGlzLmNhY2hlZC5wdXNoKHYpO1xuICB9XG5cbiAgX2ZpbmFsKCkge1xuICAgIHRoaXMuX3dyaXRlKFtudWxsXSk7XG4gIH1cblxuICBnZXQgcG9zaXRpb24oKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyUG9zO1xuICB9XG5cbiAgLyoqXG5cdCAqIGxvb2sgYWhlYWQgZm9yIDEgY2hhcmFjdGVyXG5cdCAqIEBwYXJhbSBudW0gZGVmYXVsdCBpcyAxXG5cdCAqIEByZXR1cm4gbnVsbCBpZiBFT0YgaXMgcmVhY2hlZFxuXHQgKi9cbiAgbGEobnVtID0gMSk6IFYgfCBudWxsIHtcbiAgICBjb25zdCByZWFkUG9zID0gdGhpcy5jdXJyUG9zICsgbnVtIC0gMTtcbiAgICByZXR1cm4gdGhpcy5yZWFkKHJlYWRQb3MpO1xuICB9XG5cbiAgYWR2YW5jZShjb3VudCA9IDEpOiBWIHtcbiAgICAvLyByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgbGV0IGN1cnJWYWx1ZTogVjtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkrKyA8IGNvdW50KSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMubGEoMSk7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnRocm93RXJyb3IoJ1VuZXhwZWN0IEVPRicpOyAvLyAsIHN0YWNrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0aGlzLmN1cnJQb3MrKztcbiAgICAgIHRoaXMuY29sdW1uKys7XG4gICAgICBpZiAoKHZhbHVlIGFzIGFueSkgPT09ICdcXG4nKSB7XG4gICAgICAgIHRoaXMubGluZSsrO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IDE7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jdXJyUG9zIC0gdGhpcy5jYWNoZVN0YXJ0UG9zID4gMHgxMDAwMDApIHtcbiAgICAgICAgdGhpcy5jYWNoZWQuc3BsaWNlKDAsIDB4MTAwMDAwKTtcbiAgICAgICAgdGhpcy5jYWNoZVN0YXJ0UG9zICs9IDB4MTAwMDAwO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY3VyckNodW5rICYmICF0aGlzLmN1cnJDaHVuay5pc0Nsb3NlZCAmJiB0aGlzLmN1cnJDaHVuay50cmFja1ZhbHVlKSB7XG4gICAgICAgIHRoaXMuY3VyckNodW5rLnZhbHVlcyEucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBjdXJyVmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgdGhpcy5sYXN0Q29uc3VtZWQgPSBjdXJyVmFsdWUhO1xuICAgIHJldHVybiBjdXJyVmFsdWUhO1xuICB9XG5cbiAgaXNOZXh0KC4uLnZhbHVlczogVltdKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNOZXh0V2l0aCh2YWx1ZXMpO1xuICB9XG4gIC8qKlxuXHQgKiBTYW1lIGFzIGByZXR1cm4gbGEoMSkgPT09IHZhbHVlc1swXSAmJiBsYSgyKSA9PT0gdmFsdWVzWzFdLi4uYFxuXHQgKiBAcGFyYW0gdmFsdWVzIGxvb2thaGVhZCBzdHJpbmcgb3IgdG9rZW5zXG5cdCAqL1xuICBpc05leHRXaXRoPEM+KHZhbHVlczogQ1tdLCBpc0VxdWFsID0gKGE6IFYsIGI6IEMpID0+IGEgYXMgYW55ID09PSBiKTogYm9vbGVhbiB7XG4gICAgbGV0IGNvbXBhcmVUbzogQ1tdfCBzdHJpbmc7XG4gICAgbGV0IGNvbXBhcmVGbjogKC4uLmFyZzogYW55W10pID0+IGJvb2xlYW47XG4gICAgY29tcGFyZVRvID0gdmFsdWVzO1xuICAgIGNvbXBhcmVGbiA9IGlzRXF1YWw7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IGwgPSBjb21wYXJlVG8ubGVuZ3RoO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoaSA9PT0gbClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjb25zdCBuZXh0ID0gdGhpcy5sYShpICsgMSk7XG4gICAgICBpZiAobmV4dCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEVPRlxuICAgICAgZWxzZSBpZiAoIWNvbXBhcmVGbihuZXh0LCBjb21wYXJlVG9baV0pKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG5cbiAgYXNzZXJ0QWR2YW5jZSguLi52YWx1ZXM6IFZbXSkge1xuICAgIHJldHVybiB0aGlzLmFzc2VydEFkdmFuY2VXaXRoKHZhbHVlcyk7XG4gIH1cblxuICBhc3NlcnRBZHZhbmNlV2l0aDxDPih2YWx1ZXM6IENbXSwgaXNFcXVhbCA9IChhOiBWLCBiOiBDKSA9PiBhIGFzIGFueSA9PT0gYikge1xuICAgIGxldCBjb21wYXJlVG86IENbXXwgc3RyaW5nO1xuICAgIGxldCBjb21wYXJlRm46ICguLi5hcmc6IGFueVtdKSA9PiBib29sZWFuO1xuICAgIGNvbXBhcmVUbyA9IHZhbHVlcztcbiAgICBjb21wYXJlRm4gPSBpc0VxdWFsO1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCBsID0gY29tcGFyZVRvLmxlbmd0aDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGkgPT09IGwpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY29uc3QgbmV4dCA9IHRoaXMuYWR2YW5jZShpICsgMSk7XG4gICAgICBpZiAobmV4dCA9PSBudWxsKVxuICAgICAgICB0aGlzLnRocm93RXJyb3IoJ0VPRicsIG5ldyBFcnJvcigpLnN0YWNrKTsgLy8gRU9GXG4gICAgICBlbHNlIGlmICghY29tcGFyZUZuKG5leHQsIGNvbXBhcmVUb1tpXSkpXG4gICAgICAgIHRoaXMudGhyb3dFcnJvcih1dGlsLmluc3BlY3QobmV4dCksIG5ldyBFcnJvcigpLnN0YWNrLCBjb21wYXJlVG9baV0gKyAnJyk7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG5cbiAgdGhyb3dFcnJvcih1bmV4cGVjdGVkID0gJ0VuZC1vZi1zdHJlYW0nLCBzdGFjaz86IGFueSwgZXhwZWN0Pzogc3RyaW5nKSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBtYXgtbGluZS1sZW5ndGhcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEluICR7dGhpcy5uYW1lfSB1bmV4cGVjdGVkICR7SlNPTi5zdHJpbmdpZnkodW5leHBlY3RlZCl9YCtcbiAgICAoZXhwZWN0ID8gYChleHBlY3RpbmcgXCIke2V4cGVjdH1cIilgIDogJycpICtcbiAgICBgYXQgJHt0aGlzLmdldEN1cnJlbnRQb3NJbmZvKCl9LCAke3N0YWNrID8gJ3ByZXZpb3VzIHN0YWNrOicgKyBzdGFjayA6ICcnfWApO1xuICB9XG5cbiAgZ2V0Q3VycmVudFBvc0luZm8oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYG9mZnNldCAke3RoaXMuY3VyclBvc30gWyR7dGhpcy5saW5lfToke3RoaXMuY29sdW1ufV1gO1xuICB9XG5cbiAgc3RhcnRDaHVuayh0eXBlOiBULCB0cmFja1ZhbHVlID0gdHJ1ZSkge1xuICAgIGlmICh0aGlzLmN1cnJDaHVuayAmJiAhdGhpcy5jdXJyQ2h1bmsuaXNDbG9zZWQpXG4gICAgICB0aGlzLmN1cnJDaHVuay5jbG9zZSh0aGlzLmN1cnJQb3MpO1xuICAgIHRoaXMuY3VyckNodW5rID0gbmV3IENodW5rPFYsIFQ+KHRoaXMuY3VyclBvcywgdGhpcy5saW5lLCB0aGlzLmNvbHVtbik7XG4gICAgdGhpcy5jdXJyQ2h1bmsudHJhY2tWYWx1ZSA9IHRyYWNrVmFsdWU7XG4gICAgdGhpcy5jdXJyQ2h1bmsudHlwZSA9IHR5cGU7XG4gICAgcmV0dXJuIHRoaXMuY3VyckNodW5rO1xuICB9XG5cbiAgcHJvdGVjdGVkIGNsb3NlQ2h1bmsoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VyckNodW5rLmNsb3NlKHRoaXMuY3VyclBvcyk7XG4gIH1cblxuICAvKipcblx0ICogRG8gbm90IHJlYWQgcG9zdGlvbiBsZXNzIHRoYW4gMFxuXHQgKiBAcGFyYW0gcG9zIFxuXHQgKi9cbiAgcHJpdmF0ZSByZWFkKHBvczogbnVtYmVyKTogViB8IG51bGwge1xuICAgIGNvbnN0IGNhY2hlT2Zmc2V0ID0gcG9zIC0gdGhpcy5jYWNoZVN0YXJ0UG9zO1xuICAgIGlmIChjYWNoZU9mZnNldCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuIG5vdCByZWFkIGJlaGluZCBzdHJlYW0gY2FjaGUsIGF0IHBvc2l0aW9uOiAke3Bvc31gKTtcbiAgICB9XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChjYWNoZU9mZnNldCA8IHRoaXMuY2FjaGVkLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZWRbY2FjaGVPZmZzZXRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMub25EcmFpbikge1xuICAgICAgICAgIHRoaXMub25EcmFpbigpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGludGVybmFsIGJ1ZmZlciBpcyBkcmFpbmVkIGVhcmx5IGF0ICR7cG9zfWApO1xuICAgICAgICAvLyB0aGlzLndhaXRGb3JQb3MgPSBwb3M7XG4gICAgICAgIC8vIGNvbnN0IGVyciA9IG5ldyBXYWl0RXJyb3IoKTtcbiAgICAgICAgLy8gdGhyb3cgZXJyO1xuICAgICAgICAvLyByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIC8vICAgdGhpcy5yZWFkUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIC8vIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdHJDaHVuazJUb2tlbjxUPihjaHVuazogQ2h1bms8c3RyaW5nLCBUPikge1xuICBpZiAoY2h1bmsudmFsdWVzKSB7XG4gICAgKGNodW5rIGFzIFRva2VuPFQ+KS50ZXh0ID0gY2h1bmsudmFsdWVzLmpvaW4oJycpO1xuICAgIGRlbGV0ZSBjaHVuay52YWx1ZXM7XG4gIH1cbiAgcmV0dXJuIGNodW5rIGFzIFRva2VuPFQ+O1xufVxuXG4vKipcbiAqIENvbnZlbmllbnQgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgdGV4dCBiYXNlZCBwYXJzZXIsXG4gKiB5b3Ugb25seSBuZWVkIHRvIGRlZmluZSBUb2tlbiB0eXBlcywgbGV4ZXIgZnVuY3Rpb24sIGdyYW1tYXIgZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRleHRQYXJzZXIoKSB7XG5cbn1cbiJdfQ==