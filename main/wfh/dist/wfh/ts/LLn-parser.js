"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTextParser = exports.LookAhead = exports.parser = exports.Token = exports.Chunk = exports.listTokens = exports.createStringParser = void 0;
const util_1 = __importDefault(require("util"));
/**
 * T - Token Types
 * AST - type of returned AST object
 */
function createStringParser(parserName, lexer, grammar) {
    return function (input) {
        const p = parser(parserName, lexer, grammar);
        p.write(input);
        p.end();
        return p.getResult();
    };
}
exports.createStringParser = createStringParser;
/**
 * Help for testing result of lexer function
 * @param lexer
 */
function listTokens(debugName, input, lexer) {
    const lexerLa = new LookAhead(debugName, () => {
        lexerLa._write(input);
        lexerLa._final();
    });
    const tokens = [];
    lexer(lexerLa, {
        emit() {
            const token = strChunk2Token(lexerLa.currChunk);
            token.close(lexerLa.position);
            tokens.push(token);
        },
        end() { }
    });
    return tokens;
}
exports.listTokens = listTokens;
class Chunk {
    constructor(pos, line, col) {
        this.pos = pos;
        this.line = line;
        this.col = col;
        this.values = [];
        this.isClosed = false;
        this.trackValue = true;
    }
    close(position) {
        this.isClosed = true;
        this.end = position;
        return this;
    }
}
exports.Chunk = Chunk;
class Token extends Chunk {
}
exports.Token = Token;
function parser(parserName, lexer, grammar, chunkConverter) {
    let isString;
    const lexerLa = new LookAhead(parserName + ' lexer');
    const tokenEmitter = {
        emit() {
            if (isString === undefined && lexerLa.currChunk.values != null)
                isString = typeof lexerLa.currChunk.values[0] === 'string';
            const token = chunkConverter ? chunkConverter(lexerLa.currChunk) :
                (isString ?
                    strChunk2Token(lexerLa.currChunk) :
                    lexerLa.currChunk);
            tokenLa._write([token]);
            token.close(lexerLa.position);
        },
        end() {
            tokenLa._final();
        }
    };
    const tokenLa = new LookAhead(parserName + ' grammar', function () {
        lexer(lexerLa, tokenEmitter);
    });
    return {
        write: lexerLa._write.bind(lexerLa),
        end: lexerLa._final.bind(lexerLa),
        getResult() {
            return grammar(tokenLa);
        }
    };
}
exports.parser = parser;
class LookAhead {
    constructor(name, onDrain) {
        this.name = name;
        this.onDrain = onDrain;
        this.line = 1;
        this.column = 1;
        this.currPos = 0;
        this.cacheStartPos = 0;
        this.cached = [];
    }
    _write(values) {
        for (const v of values)
            this.cached.push(v);
    }
    _final() {
        this._write([null]);
    }
    get position() {
        return this.currPos;
    }
    /**
       * look ahead for 1 character
       * @param num default is 1
       * @return null if EOF is reached
       */
    la(num = 1) {
        const readPos = this.currPos + num - 1;
        return this.read(readPos);
    }
    advance(count = 1) {
        // return new Promise(resolve => {
        let currValue;
        let i = 0;
        while (i++ < count) {
            const value = this.la(1);
            if (value == null) {
                this.throwError('Unexpect EOF'); // , stack);
                break;
            }
            this.currPos++;
            this.column++;
            if (value === '\n') {
                this.line++;
                this.column = 1;
            }
            if (this.currPos - this.cacheStartPos > 0x100000) {
                this.cached.splice(0, 0x100000);
                this.cacheStartPos += 0x100000;
            }
            if (this.currChunk && !this.currChunk.isClosed && this.currChunk.trackValue) {
                this.currChunk.values.push(value);
            }
            currValue = value;
        }
        this.lastConsumed = currValue;
        return currValue;
    }
    isNext(...values) {
        return this.isNextWith(values);
    }
    /**
       * Same as `return la(1) === values[0] && la(2) === values[1]...`
       * @param values lookahead string or tokens
       */
    isNextWith(values, isEqual = (a, b) => a === b) {
        let compareTo;
        let compareFn;
        compareTo = values;
        compareFn = isEqual;
        let i = 0;
        const l = compareTo.length;
        while (true) {
            if (i === l)
                return true;
            const next = this.la(i + 1);
            if (next == null)
                return false; // EOF
            else if (!compareFn(next, compareTo[i]))
                return false;
            i++;
        }
    }
    assertAdvance(...values) {
        return this.assertAdvanceWith(values);
    }
    assertAdvanceWith(values, isEqual = (a, b) => a === b) {
        let compareTo;
        let compareFn;
        compareTo = values;
        compareFn = isEqual;
        let i = 0;
        const l = compareTo.length;
        while (true) {
            if (i === l)
                return true;
            const next = this.advance(i + 1);
            if (next == null)
                this.throwError('EOF', new Error().stack); // EOF
            else if (!compareFn(next, compareTo[i]))
                this.throwError(util_1.default.inspect(next), new Error().stack, compareTo[i] + '');
            i++;
        }
    }
    throwError(unexpected = 'End-of-stream', stack, expect) {
        // tslint:disable-next-line: max-line-length
        throw new Error(`In ${this.name} unexpected ${JSON.stringify(unexpected)}` +
            (expect ? `(expecting "${expect}")` : '') +
            `at ${this.getCurrentPosInfo()}, ${stack ? 'previous stack:' + stack : ''}`);
    }
    getCurrentPosInfo() {
        return `offset ${this.currPos} [${this.line}:${this.column}]`;
    }
    startChunk(type, trackValue = true) {
        if (this.currChunk && !this.currChunk.isClosed)
            this.currChunk.close(this.currPos);
        this.currChunk = new Chunk(this.currPos, this.line, this.column);
        this.currChunk.trackValue = trackValue;
        this.currChunk.type = type;
        return this.currChunk;
    }
    closeChunk() {
        return this.currChunk.close(this.currPos);
    }
    /**
       * Do not read postion less than 0
       * @param pos
       */
    read(pos) {
        const cacheOffset = pos - this.cacheStartPos;
        if (cacheOffset < 0) {
            throw new Error(`Can not read behind stream cache, at position: ${pos}`);
        }
        while (true) {
            if (cacheOffset < this.cached.length) {
                return this.cached[cacheOffset];
            }
            else {
                if (this.onDrain) {
                    this.onDrain();
                    continue;
                }
                throw new Error(`The internal buffer is drained early at ${pos}`);
                // this.waitForPos = pos;
                // const err = new WaitError();
                // throw err;
                // return new Promise(resolve => {
                //   this.readResolve = resolve;
                // });
            }
        }
    }
}
exports.LookAhead = LookAhead;
function strChunk2Token(chunk) {
    if (chunk.values) {
        chunk.text = chunk.values.join('');
        delete chunk.values;
    }
    return chunk;
}
/**
 * Convenient function for creating a text based parser,
 * you only need to define Token types, lexer function, grammar function
 */
function createTextParser() {
}
exports.createTextParser = createTextParser;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTExuLXBhcnNlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3RzL0xMbi1wYXJzZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsZ0RBQXdCO0FBRXhCOzs7R0FHRztBQUNILFNBQWdCLGtCQUFrQixDQUFTLFVBQWtCLEVBQUUsS0FBdUIsRUFDcEYsT0FBK0I7SUFFL0IsT0FBTyxVQUFTLEtBQWE7UUFDM0IsTUFBTSxDQUFDLEdBQUcsTUFBTSxDQUFDLFVBQVUsRUFBRSxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDN0MsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNmLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNSLE9BQU8sQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUFDO0lBQ3ZCLENBQUMsQ0FBQztBQUNKLENBQUM7QUFURCxnREFTQztBQUVEOzs7R0FHRztBQUNILFNBQWdCLFVBQVUsQ0FBSSxTQUFpQixFQUFFLEtBQWEsRUFBRSxLQUF1QjtJQUNyRixNQUFNLE9BQU8sR0FBRyxJQUFJLFNBQVMsQ0FBWSxTQUFTLEVBQUUsR0FBRyxFQUFFO1FBQ3ZELE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDdEIsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDO0lBQ25CLENBQUMsQ0FBQyxDQUFDO0lBRUgsTUFBTSxNQUFNLEdBQUcsRUFBZ0IsQ0FBQztJQUNoQyxLQUFLLENBQUMsT0FBTyxFQUFFO1FBQ2IsSUFBSTtZQUNGLE1BQU0sS0FBSyxHQUFHLGNBQWMsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDaEQsS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDOUIsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNyQixDQUFDO1FBQ0QsR0FBRyxLQUFJLENBQUM7S0FDVCxDQUFDLENBQUM7SUFF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LFdBQVcsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQztRQUM3QyxJQUFJLFdBQVcsR0FBRyxDQUFDLEVBQUU7WUFDbkIsTUFBTSxJQUFJLEtBQUssQ0FBQyxrREFBa0QsR0FBRyxFQUFFLENBQUMsQ0FBQztTQUMxRTtRQUNELE9BQU8sSUFBSSxFQUFFO1lBQ1gsSUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUU7Z0JBQ3BDLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQzthQUNqQztpQkFBTTtnQkFDTCxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7b0JBQ2hCLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztvQkFDZixTQUFTO2lCQUNWO2dCQUNELE1BQU0sSUFBSSxLQUFLLENBQUMsMkNBQTJDLEdBQUcsRUFBRSxDQUFDLENBQUM7Z0JBQ2xFLHlCQUF5QjtnQkFDekIsK0JBQStCO2dCQUMvQixhQUFhO2dCQUNiLGtDQUFrQztnQkFDbEMsZ0NBQWdDO2dCQUNoQyxNQUFNO2FBQ1A7U0FDRjtJQUNILENBQUM7Q0FDRjtBQXZLRCw4QkF1S0M7QUFFRCxTQUFTLGNBQWMsQ0FBSSxLQUF1QjtJQUNoRCxJQUFJLEtBQUssQ0FBQyxNQUFNLEVBQUU7UUFDZixLQUFrQixDQUFDLElBQUksR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNqRCxPQUFPLEtBQUssQ0FBQyxNQUFNLENBQUM7S0FDckI7SUFDRCxPQUFPLEtBQWlCLENBQUM7QUFDM0IsQ0FBQztBQUVEOzs7R0FHRztBQUNILFNBQWdCLGdCQUFnQjtBQUVoQyxDQUFDO0FBRkQsNENBRUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdXRpbCBmcm9tICd1dGlsJztcblxuLyoqXG4gKiBUIC0gVG9rZW4gVHlwZXNcbiAqIEFTVCAtIHR5cGUgb2YgcmV0dXJuZWQgQVNUIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3RyaW5nUGFyc2VyPFQsIEFTVD4ocGFyc2VyTmFtZTogc3RyaW5nLCBsZXhlcjogTGV4ZXI8c3RyaW5nLCBUPixcbiAgZ3JhbW1hcjogR3JhbW1hcjxUb2tlbjxUPiwgQVNUPikge1xuXG4gIHJldHVybiBmdW5jdGlvbihpbnB1dDogc3RyaW5nKSB7XG4gICAgY29uc3QgcCA9IHBhcnNlcihwYXJzZXJOYW1lLCBsZXhlciwgZ3JhbW1hcik7XG4gICAgcC53cml0ZShpbnB1dCk7XG4gICAgcC5lbmQoKTtcbiAgICByZXR1cm4gcC5nZXRSZXN1bHQoKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwIGZvciB0ZXN0aW5nIHJlc3VsdCBvZiBsZXhlciBmdW5jdGlvblxuICogQHBhcmFtIGxleGVyIFxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdFRva2VuczxUPihkZWJ1Z05hbWU6IHN0cmluZywgaW5wdXQ6IHN0cmluZywgbGV4ZXI6IExleGVyPHN0cmluZywgVD4pOiBUb2tlbjxUPltdIHtcbiAgY29uc3QgbGV4ZXJMYSA9IG5ldyBMb29rQWhlYWQ8c3RyaW5nLCBUPihkZWJ1Z05hbWUsICgpID0+IHtcbiAgICBsZXhlckxhLl93cml0ZShpbnB1dCk7XG4gICAgbGV4ZXJMYS5fZmluYWwoKTtcbiAgfSk7XG5cbiAgY29uc3QgdG9rZW5zID0gW10gYXMgVG9rZW48VD5bXTtcbiAgbGV4ZXIobGV4ZXJMYSwge1xuICAgIGVtaXQoKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IHN0ckNodW5rMlRva2VuKGxleGVyTGEuY3VyckNodW5rKTtcbiAgICAgIHRva2VuLmNsb3NlKGxleGVyTGEucG9zaXRpb24pO1xuICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgIH0sXG4gICAgZW5kKCkge31cbiAgfSk7XG5cbiAgcmV0dXJuIHRva2Vucztcbn1cbmV4cG9ydCBjbGFzcyBDaHVuazxWLCBUPiB7XG4gIHR5cGU6IFQ7XG4gIHZhbHVlcz86IFZbXSA9IFtdO1xuICBlbmQ6IG51bWJlcjtcbiAgaXNDbG9zZWQgPSBmYWxzZTtcbiAgdHJhY2tWYWx1ZSA9IHRydWU7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHBvczogbnVtYmVyLCBwdWJsaWMgbGluZTogbnVtYmVyLCBwdWJsaWMgY29sOiBudW1iZXJcbiAgKSB7fVxuXG4gIGNsb3NlKHBvc2l0aW9uOiBudW1iZXIpIHtcbiAgICB0aGlzLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLmVuZCA9IHBvc2l0aW9uO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBUb2tlbjxUPiBleHRlbmRzIENodW5rPHN0cmluZywgVD4ge1xuICB0ZXh0OiBzdHJpbmc7XG59XG5cbi8qKlxuICogIFYgaXMgdHlwZSBvZiBlYWNoIGBjaGFyYWN0ZXJgLCBlLmcuIHN0cmluZywgbnVtYmVyXG4gKiAgVCBpcyBUb2tlbiBUeXBlLCBlLmcuIHN0cmluZyBvciBhIGVudW1cbiAqICBDIGNvdWxkIGJlIG9taXRcbiAqL1xuZXhwb3J0IHR5cGUgTGV4ZXI8VixULCBDIGV4dGVuZHMgQ2h1bms8ViwgVD4gPSBDaHVuazxWLCBUPj4gPVxuICAobGE6IExvb2tBaGVhZDxWLFQ+LCBlbWl0dGVyOiBUb2tlbkVtaXR0ZXI8ViwgVCwgQz4pID0+IHZvaWQ7XG5leHBvcnQgdHlwZSBHcmFtbWFyPEMsIEE+ID0gKHRva2VuTGE6IExvb2tBaGVhZDxDPikgPT4gQTtcblxuaW50ZXJmYWNlIFRva2VuRW1pdHRlcjxWLCBULCBDPiB7XG4gIGVtaXQoKTogdm9pZDtcbiAgZW5kKCk6IHZvaWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZXI8ViwgVCwgQyBleHRlbmRzIENodW5rPFYsIFQ+LCBBPihwYXJzZXJOYW1lOiBzdHJpbmcsXG4gIGxleGVyOiBMZXhlcjxWLCBULCBDPixcbiAgZ3JhbW1hcjogR3JhbW1hcjxDLCBBPixcbiAgY2h1bmtDb252ZXJ0ZXI/OiAoY2h1bms6IENodW5rPFYsIFQ+KSA9PiBDKTpcbiAge1xuICAgIHdyaXRlOiBMb29rQWhlYWQ8ViwgVD5bJ193cml0ZSddO1xuICAgIGVuZDogTG9va0FoZWFkPFYsIFQ+WydfZmluYWwnXTtcbiAgICBnZXRSZXN1bHQ6ICgpID0+IEFcbiAgfSB7XG5cbiAgbGV0IGlzU3RyaW5nOiBib29sZWFuO1xuICBjb25zdCBsZXhlckxhID0gbmV3IExvb2tBaGVhZDxWLCBUPihwYXJzZXJOYW1lKyAnIGxleGVyJyk7XG4gIGNvbnN0IHRva2VuRW1pdHRlcjogVG9rZW5FbWl0dGVyPFYsIFQsIEM+ID0ge1xuICAgIGVtaXQoKSB7XG4gICAgICBpZiAoaXNTdHJpbmcgPT09IHVuZGVmaW5lZCAmJiBsZXhlckxhLmN1cnJDaHVuay52YWx1ZXMgIT0gbnVsbClcbiAgICAgICAgaXNTdHJpbmcgPSB0eXBlb2YgbGV4ZXJMYS5jdXJyQ2h1bmsudmFsdWVzWzBdID09PSAnc3RyaW5nJztcbiAgICAgIGNvbnN0IHRva2VuOiBDID0gY2h1bmtDb252ZXJ0ZXIgPyBjaHVua0NvbnZlcnRlcihsZXhlckxhLmN1cnJDaHVuaykgOlxuICAgICAgICAoaXNTdHJpbmcgP1xuICAgICAgICAgIHN0ckNodW5rMlRva2VuKGxleGVyTGEuY3VyckNodW5rIGFzIHVua25vd24gYXMgQ2h1bms8c3RyaW5nLCBUPikgYXMgdW5rbm93biBhcyBDIDpcbiAgICAgICAgICBsZXhlckxhLmN1cnJDaHVuayBhcyBDKTtcbiAgICAgIHRva2VuTGEuX3dyaXRlKFt0b2tlbl0pO1xuICAgICAgdG9rZW4uY2xvc2UobGV4ZXJMYS5wb3NpdGlvbik7XG4gICAgfSxcbiAgICBlbmQoKSB7XG4gICAgICB0b2tlbkxhLl9maW5hbCgpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdG9rZW5MYSA9IG5ldyBMb29rQWhlYWQ8Qz4ocGFyc2VyTmFtZSArICcgZ3JhbW1hcicsIGZ1bmN0aW9uKCkge1xuICAgIGxleGVyKGxleGVyTGEsIHRva2VuRW1pdHRlcik7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHdyaXRlOiBsZXhlckxhLl93cml0ZS5iaW5kKGxleGVyTGEpLFxuICAgIGVuZDogbGV4ZXJMYS5fZmluYWwuYmluZChsZXhlckxhKSxcbiAgICBnZXRSZXN1bHQoKSB7XG4gICAgICByZXR1cm4gZ3JhbW1hcih0b2tlbkxhKTtcbiAgICB9XG4gIH07XG59XG5cblxuZXhwb3J0IGNsYXNzIExvb2tBaGVhZDxWLCBUID0gdm9pZD4ge1xuICBzdGF0aWMgV0FJVF9FUlJPUjogJ1dBSVRfRVJST1InO1xuICBjYWNoZWQ6IEFycmF5PFZ8bnVsbD47XG4gIGxpbmUgPSAxO1xuICBjb2x1bW4gPSAxO1xuICBsYXN0Q29uc3VtZWQ6IFY7XG4gIGN1cnJDaHVuazogQ2h1bms8ViwgVD47XG5cbiAgcHJpdmF0ZSBjdXJyUG9zID0gMDtcbiAgcHJpdmF0ZSBjYWNoZVN0YXJ0UG9zID0gMDtcblxuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgbmFtZTogc3RyaW5nLCBwcml2YXRlIG9uRHJhaW4/OiAodGhpczogTG9va0FoZWFkPFYsIFQ+KSA9PiB2b2lkKSB7XG4gICAgdGhpcy5jYWNoZWQgPSBbXTtcbiAgfVxuXG4gIF93cml0ZSh2YWx1ZXM6IEl0ZXJhYmxlPFZ8bnVsbD4pIHtcbiAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWVzKVxuICAgICAgdGhpcy5jYWNoZWQucHVzaCh2KTtcbiAgfVxuXG4gIF9maW5hbCgpIHtcbiAgICB0aGlzLl93cml0ZShbbnVsbF0pO1xuICB9XG5cbiAgZ2V0IHBvc2l0aW9uKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuY3VyclBvcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBsb29rIGFoZWFkIGZvciAxIGNoYXJhY3RlclxuXHQgKiBAcGFyYW0gbnVtIGRlZmF1bHQgaXMgMVxuXHQgKiBAcmV0dXJuIG51bGwgaWYgRU9GIGlzIHJlYWNoZWRcblx0ICovXG4gIGxhKG51bSA9IDEpOiBWIHwgbnVsbCB7XG4gICAgY29uc3QgcmVhZFBvcyA9IHRoaXMuY3VyclBvcyArIG51bSAtIDE7XG4gICAgcmV0dXJuIHRoaXMucmVhZChyZWFkUG9zKTtcbiAgfVxuXG4gIGFkdmFuY2UoY291bnQgPSAxKTogViB7XG4gICAgLy8gcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGxldCBjdXJyVmFsdWU6IFY7XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpKysgPCBjb3VudCkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmxhKDEpO1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgdGhpcy50aHJvd0Vycm9yKCdVbmV4cGVjdCBFT0YnKTsgLy8gLCBzdGFjayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGhpcy5jdXJyUG9zKys7XG4gICAgICB0aGlzLmNvbHVtbisrO1xuICAgICAgaWYgKCh2YWx1ZSBhcyBhbnkpID09PSAnXFxuJykge1xuICAgICAgICB0aGlzLmxpbmUrKztcbiAgICAgICAgdGhpcy5jb2x1bW4gPSAxO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY3VyclBvcyAtIHRoaXMuY2FjaGVTdGFydFBvcyA+IDB4MTAwMDAwKSB7XG4gICAgICAgIHRoaXMuY2FjaGVkLnNwbGljZSgwLCAweDEwMDAwMCk7XG4gICAgICAgIHRoaXMuY2FjaGVTdGFydFBvcyArPSAweDEwMDAwMDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmN1cnJDaHVuayAmJiAhdGhpcy5jdXJyQ2h1bmsuaXNDbG9zZWQgJiYgdGhpcy5jdXJyQ2h1bmsudHJhY2tWYWx1ZSkge1xuICAgICAgICB0aGlzLmN1cnJDaHVuay52YWx1ZXMhLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgICAgY3VyclZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHRoaXMubGFzdENvbnN1bWVkID0gY3VyclZhbHVlITtcbiAgICByZXR1cm4gY3VyclZhbHVlITtcbiAgfVxuXG4gIGlzTmV4dCguLi52YWx1ZXM6IFZbXSkge1xuICAgIHJldHVybiB0aGlzLmlzTmV4dFdpdGgodmFsdWVzKTtcbiAgfVxuICAvKipcblx0ICogU2FtZSBhcyBgcmV0dXJuIGxhKDEpID09PSB2YWx1ZXNbMF0gJiYgbGEoMikgPT09IHZhbHVlc1sxXS4uLmBcblx0ICogQHBhcmFtIHZhbHVlcyBsb29rYWhlYWQgc3RyaW5nIG9yIHRva2Vuc1xuXHQgKi9cbiAgaXNOZXh0V2l0aDxDPih2YWx1ZXM6IENbXSwgaXNFcXVhbCA9IChhOiBWLCBiOiBDKSA9PiBhIGFzIGFueSA9PT0gYik6IGJvb2xlYW4ge1xuICAgIGxldCBjb21wYXJlVG86IENbXXwgc3RyaW5nO1xuICAgIGxldCBjb21wYXJlRm46ICguLi5hcmc6IGFueVtdKSA9PiBib29sZWFuO1xuICAgIGNvbXBhcmVUbyA9IHZhbHVlcztcbiAgICBjb21wYXJlRm4gPSBpc0VxdWFsO1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCBsID0gY29tcGFyZVRvLmxlbmd0aDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGkgPT09IGwpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY29uc3QgbmV4dCA9IHRoaXMubGEoaSArIDEpO1xuICAgICAgaWYgKG5leHQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBFT0ZcbiAgICAgIGVsc2UgaWYgKCFjb21wYXJlRm4obmV4dCwgY29tcGFyZVRvW2ldKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuXG4gIGFzc2VydEFkdmFuY2UoLi4udmFsdWVzOiBWW10pIHtcbiAgICByZXR1cm4gdGhpcy5hc3NlcnRBZHZhbmNlV2l0aCh2YWx1ZXMpO1xuICB9XG5cbiAgYXNzZXJ0QWR2YW5jZVdpdGg8Qz4odmFsdWVzOiBDW10sIGlzRXF1YWwgPSAoYTogViwgYjogQykgPT4gYSBhcyBhbnkgPT09IGIpIHtcbiAgICBsZXQgY29tcGFyZVRvOiBDW118IHN0cmluZztcbiAgICBsZXQgY29tcGFyZUZuOiAoLi4uYXJnOiBhbnlbXSkgPT4gYm9vbGVhbjtcbiAgICBjb21wYXJlVG8gPSB2YWx1ZXM7XG4gICAgY29tcGFyZUZuID0gaXNFcXVhbDtcbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3QgbCA9IGNvbXBhcmVUby5sZW5ndGg7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChpID09PSBsKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmFkdmFuY2UoaSArIDEpO1xuICAgICAgaWYgKG5leHQgPT0gbnVsbClcbiAgICAgICAgdGhpcy50aHJvd0Vycm9yKCdFT0YnLCBuZXcgRXJyb3IoKS5zdGFjayk7IC8vIEVPRlxuICAgICAgZWxzZSBpZiAoIWNvbXBhcmVGbihuZXh0LCBjb21wYXJlVG9baV0pKVxuICAgICAgICB0aGlzLnRocm93RXJyb3IodXRpbC5pbnNwZWN0KG5leHQpLCBuZXcgRXJyb3IoKS5zdGFjaywgY29tcGFyZVRvW2ldICsgJycpO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuXG4gIHRocm93RXJyb3IodW5leHBlY3RlZCA9ICdFbmQtb2Ytc3RyZWFtJywgc3RhY2s/OiBhbnksIGV4cGVjdD86IHN0cmluZykge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbWF4LWxpbmUtbGVuZ3RoXG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbiAke3RoaXMubmFtZX0gdW5leHBlY3RlZCAke0pTT04uc3RyaW5naWZ5KHVuZXhwZWN0ZWQpfWArXG4gICAgKGV4cGVjdCA/IGAoZXhwZWN0aW5nIFwiJHtleHBlY3R9XCIpYCA6ICcnKSArXG4gICAgYGF0ICR7dGhpcy5nZXRDdXJyZW50UG9zSW5mbygpfSwgJHtzdGFjayA/ICdwcmV2aW91cyBzdGFjazonICsgc3RhY2sgOiAnJ31gKTtcbiAgfVxuXG4gIGdldEN1cnJlbnRQb3NJbmZvKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBvZmZzZXQgJHt0aGlzLmN1cnJQb3N9IFske3RoaXMubGluZX06JHt0aGlzLmNvbHVtbn1dYDtcbiAgfVxuXG4gIHN0YXJ0Q2h1bmsodHlwZTogVCwgdHJhY2tWYWx1ZSA9IHRydWUpIHtcbiAgICBpZiAodGhpcy5jdXJyQ2h1bmsgJiYgIXRoaXMuY3VyckNodW5rLmlzQ2xvc2VkKVxuICAgICAgdGhpcy5jdXJyQ2h1bmsuY2xvc2UodGhpcy5jdXJyUG9zKTtcbiAgICB0aGlzLmN1cnJDaHVuayA9IG5ldyBDaHVuazxWLCBUPih0aGlzLmN1cnJQb3MsIHRoaXMubGluZSwgdGhpcy5jb2x1bW4pO1xuICAgIHRoaXMuY3VyckNodW5rLnRyYWNrVmFsdWUgPSB0cmFja1ZhbHVlO1xuICAgIHRoaXMuY3VyckNodW5rLnR5cGUgPSB0eXBlO1xuICAgIHJldHVybiB0aGlzLmN1cnJDaHVuaztcbiAgfVxuXG4gIHByb3RlY3RlZCBjbG9zZUNodW5rKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJDaHVuay5jbG9zZSh0aGlzLmN1cnJQb3MpO1xuICB9XG5cbiAgLyoqXG5cdCAqIERvIG5vdCByZWFkIHBvc3Rpb24gbGVzcyB0aGFuIDBcblx0ICogQHBhcmFtIHBvcyBcblx0ICovXG4gIHByaXZhdGUgcmVhZChwb3M6IG51bWJlcik6IFYgfCBudWxsIHtcbiAgICBjb25zdCBjYWNoZU9mZnNldCA9IHBvcyAtIHRoaXMuY2FjaGVTdGFydFBvcztcbiAgICBpZiAoY2FjaGVPZmZzZXQgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbiBub3QgcmVhZCBiZWhpbmQgc3RyZWFtIGNhY2hlLCBhdCBwb3NpdGlvbjogJHtwb3N9YCk7XG4gICAgfVxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoY2FjaGVPZmZzZXQgPCB0aGlzLmNhY2hlZC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkW2NhY2hlT2Zmc2V0XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLm9uRHJhaW4pIHtcbiAgICAgICAgICB0aGlzLm9uRHJhaW4oKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBpbnRlcm5hbCBidWZmZXIgaXMgZHJhaW5lZCBlYXJseSBhdCAke3Bvc31gKTtcbiAgICAgICAgLy8gdGhpcy53YWl0Rm9yUG9zID0gcG9zO1xuICAgICAgICAvLyBjb25zdCBlcnIgPSBuZXcgV2FpdEVycm9yKCk7XG4gICAgICAgIC8vIHRocm93IGVycjtcbiAgICAgICAgLy8gcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAvLyAgIHRoaXMucmVhZFJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAvLyB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RyQ2h1bmsyVG9rZW48VD4oY2h1bms6IENodW5rPHN0cmluZywgVD4pIHtcbiAgaWYgKGNodW5rLnZhbHVlcykge1xuICAgIChjaHVuayBhcyBUb2tlbjxUPikudGV4dCA9IGNodW5rLnZhbHVlcy5qb2luKCcnKTtcbiAgICBkZWxldGUgY2h1bmsudmFsdWVzO1xuICB9XG4gIHJldHVybiBjaHVuayBhcyBUb2tlbjxUPjtcbn1cblxuLyoqXG4gKiBDb252ZW5pZW50IGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIHRleHQgYmFzZWQgcGFyc2VyLFxuICogeW91IG9ubHkgbmVlZCB0byBkZWZpbmUgVG9rZW4gdHlwZXMsIGxleGVyIGZ1bmN0aW9uLCBncmFtbWFyIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUZXh0UGFyc2VyKCkge1xuXG59XG4iXX0=