"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DFS = exports.getPathTo = exports.Color = void 0;
var Color;
(function (Color) {
    Color[Color["white"] = 0] = "white";
    Color[Color["gray"] = 1] = "gray";
    Color[Color["black"] = 2] = "black";
})(Color = exports.Color || (exports.Color = {}));
class Vertex {
    constructor(data, color = Color.white) {
        this.data = data;
        this.color = color;
    }
}
function getPathTo(v, temp = []) {
    if (v.p) {
        getPathTo(v.p[0], temp);
    }
    temp.push(v);
}
exports.getPathTo = getPathTo;
class DFS {
    constructor(adjacencyOf) {
        this.adjacencyOf = adjacencyOf;
        this.backEdges = [];
        this.time = 0;
        this.vertexMap = new Map();
    }
    visit(g) {
        this.time = 0;
        for (const data of g) {
            const u = this.vertexOf(data);
            if (u.color === Color.white) {
                this.visitVertex(u);
            }
        }
    }
    vertexOf(data) {
        if (this.vertexMap.has(data)) {
            return this.vertexMap.get(data);
        }
        else {
            const v = new Vertex(data);
            this.vertexMap.set(data, v);
            return v;
        }
    }
    printCyclicBackEdge(edge, edgeTo) {
        return [...this._printParentUntil(edge, edgeTo), edgeTo.data + ''];
    }
    _printParentUntil(edge, edgeAncestor) {
        if (edge == null) {
            return [];
        }
        if (edge === edgeAncestor) {
            return [edgeAncestor.data + ''];
        }
        if (edge.p)
            return [...this._printParentUntil(edge.p[0], edgeAncestor), edge.data + ''];
        else
            return ['? -> ', edge.data + ''];
    }
    visitVertex(u) {
        u.d = ++this.time;
        u.color = Color.gray;
        for (const vData of this.adjacencyOf(u.data)) {
            const v = this.vertexOf(vData);
            if (v.color === Color.white) {
                v.p = [u];
                this.visitVertex(v);
            }
            else if (v.color === Color.gray) {
                this.backEdges.push([u, v]);
            }
            else {
                if (v.p == null)
                    v.p = [];
                v.p.push(u);
            }
        }
        u.color = Color.black;
        u.f = ++this.time;
    }
}
exports.DFS = DFS;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JhcGguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi90cy91dGlscy9ncmFwaC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxJQUFZLEtBSVg7QUFKRCxXQUFZLEtBQUs7SUFDZixtQ0FBUyxDQUFBO0lBQ1QsaUNBQUksQ0FBQTtJQUNKLG1DQUFLLENBQUE7QUFDUCxDQUFDLEVBSlcsS0FBSyxHQUFMLGFBQUssS0FBTCxhQUFLLFFBSWhCO0FBRUQsTUFBTSxNQUFNO0lBUVYsWUFBbUIsSUFBTyxFQUFTLFFBQVEsS0FBSyxDQUFDLEtBQUs7UUFBbkMsU0FBSSxHQUFKLElBQUksQ0FBRztRQUFTLFVBQUssR0FBTCxLQUFLLENBQWM7SUFBRyxDQUFDO0NBQzNEO0FBRUQsU0FBZ0IsU0FBUyxDQUFJLENBQVksRUFBRSxPQUFPLEVBQWlCO0lBQ2pFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRTtRQUNQLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0tBQ3pCO0lBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNmLENBQUM7QUFMRCw4QkFLQztBQUVELE1BQWEsR0FBRztJQU1kLFlBQW9CLFdBQWtDO1FBQWxDLGdCQUFXLEdBQVgsV0FBVyxDQUF1QjtRQUx0RCxjQUFTLEdBQTZCLEVBQUUsQ0FBQztRQUVqQyxTQUFJLEdBQUcsQ0FBQyxDQUFDO1FBQ1QsY0FBUyxHQUFHLElBQUksR0FBRyxFQUFnQixDQUFDO0lBRWEsQ0FBQztJQUUxRCxLQUFLLENBQUMsQ0FBYztRQUNsQixJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztRQUNkLEtBQUssTUFBTSxJQUFJLElBQUksQ0FBQyxFQUFFO1lBQ3BCLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDOUIsSUFBSSxDQUFDLENBQUMsS0FBSyxLQUFLLEtBQUssQ0FBQyxLQUFLLEVBQUU7Z0JBQzNCLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDckI7U0FDRjtJQUNILENBQUM7SUFFRCxRQUFRLENBQUMsSUFBTztRQUNkLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDNUIsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUUsQ0FBQztTQUNsQzthQUFNO1lBQ0wsTUFBTSxDQUFDLEdBQUcsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDM0IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQzVCLE9BQU8sQ0FBQyxDQUFDO1NBQ1Y7SUFDSCxDQUFDO0lBRUQsbUJBQW1CLENBQUMsSUFBZSxFQUFFLE1BQWlCO1FBQ3BELE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLEVBQUUsTUFBTSxDQUFDLElBQUksR0FBRSxFQUFFLENBQUMsQ0FBQztJQUNwRSxDQUFDO0lBRUQsaUJBQWlCLENBQUMsSUFBZSxFQUFFLFlBQXVCO1FBQ3hELElBQUksSUFBSSxJQUFJLElBQUksRUFBRTtZQUNoQixPQUFPLEVBQUUsQ0FBQztTQUNYO1FBQ0QsSUFBSSxJQUFJLEtBQUssWUFBWSxFQUFFO1lBQ3pCLE9BQU8sQ0FBQyxZQUFZLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQyxDQUFDO1NBQ2pDO1FBQ0QsSUFBSSxJQUFJLENBQUMsQ0FBQztZQUNSLE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLFlBQVksQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDLENBQUM7O1lBRTVFLE9BQU8sQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRU8sV0FBVyxDQUFDLENBQVk7UUFDOUIsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDbEIsQ0FBQyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDO1FBQ3JCLEtBQUssTUFBTSxLQUFLLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDNUMsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUMvQixJQUFJLENBQUMsQ0FBQyxLQUFLLEtBQUssS0FBSyxDQUFDLEtBQUssRUFBRTtnQkFDM0IsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNWLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDckI7aUJBQU0sSUFBSSxDQUFDLENBQUMsS0FBSyxLQUFLLEtBQUssQ0FBQyxJQUFJLEVBQUU7Z0JBQ2pDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDN0I7aUJBQU07Z0JBQ0wsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUk7b0JBQ2IsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7Z0JBQ1gsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDYjtTQUNGO1FBQ0QsQ0FBQyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDO1FBQ3RCLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ3BCLENBQUM7Q0FDRjtBQWhFRCxrQkFnRUMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZW51bSBDb2xvciB7XG4gIHdoaXRlID0gMCxcbiAgZ3JheSxcbiAgYmxhY2tcbn1cblxuY2xhc3MgVmVydGV4PFQ+IHtcbiAgLyoqIGRpc2NvdmVyeSB0aW1lICovXG4gIGQ6IG51bWJlcjtcbiAgLyoqIGZpbmlzaGluZyB0aW1lICovXG4gIGY6IG51bWJlcjtcbiAgLyoqIHBhcmVudCB2ZXJ0aWNlcyAqL1xuICBwPzogVmVydGV4PFQ+W107XG5cbiAgY29uc3RydWN0b3IocHVibGljIGRhdGE6IFQsIHB1YmxpYyBjb2xvciA9IENvbG9yLndoaXRlKSB7fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGF0aFRvPFQ+KHY6IFZlcnRleDxUPiwgdGVtcCA9IFtdIGFzIFZlcnRleDxUPltdKSB7XG4gIGlmICh2LnApIHtcbiAgICBnZXRQYXRoVG8odi5wWzBdLCB0ZW1wKTtcbiAgfVxuICB0ZW1wLnB1c2godik7XG59XG5cbmV4cG9ydCBjbGFzcyBERlM8VD4ge1xuICBiYWNrRWRnZXM6IFtWZXJ0ZXg8VD4sIFZlcnRleDxUPl1bXSA9IFtdO1xuXG4gIHByaXZhdGUgdGltZSA9IDA7XG4gIHByaXZhdGUgdmVydGV4TWFwID0gbmV3IE1hcDxULCBWZXJ0ZXg8VD4+KCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBhZGphY2VuY3lPZjogKHU6IFQpID0+IEl0ZXJhYmxlPFQ+KSB7fVxuXG4gIHZpc2l0KGc6IEl0ZXJhYmxlPFQ+KSB7XG4gICAgdGhpcy50aW1lID0gMDtcbiAgICBmb3IgKGNvbnN0IGRhdGEgb2YgZykge1xuICAgICAgY29uc3QgdSA9IHRoaXMudmVydGV4T2YoZGF0YSk7XG4gICAgICBpZiAodS5jb2xvciA9PT0gQ29sb3Iud2hpdGUpIHtcbiAgICAgICAgdGhpcy52aXNpdFZlcnRleCh1KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2ZXJ0ZXhPZihkYXRhOiBUKSB7XG4gICAgaWYgKHRoaXMudmVydGV4TWFwLmhhcyhkYXRhKSkge1xuICAgICAgcmV0dXJuIHRoaXMudmVydGV4TWFwLmdldChkYXRhKSE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHYgPSBuZXcgVmVydGV4KGRhdGEpO1xuICAgICAgdGhpcy52ZXJ0ZXhNYXAuc2V0KGRhdGEsIHYpO1xuICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICB9XG5cbiAgcHJpbnRDeWNsaWNCYWNrRWRnZShlZGdlOiBWZXJ0ZXg8VD4sIGVkZ2VUbzogVmVydGV4PFQ+KTogc3RyaW5nW10ge1xuICAgIHJldHVybiBbLi4udGhpcy5fcHJpbnRQYXJlbnRVbnRpbChlZGdlLCBlZGdlVG8pLCBlZGdlVG8uZGF0YSArJyddO1xuICB9XG5cbiAgX3ByaW50UGFyZW50VW50aWwoZWRnZTogVmVydGV4PFQ+LCBlZGdlQW5jZXN0b3I6IFZlcnRleDxUPik6IHN0cmluZ1tdIHtcbiAgICBpZiAoZWRnZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChlZGdlID09PSBlZGdlQW5jZXN0b3IpIHtcbiAgICAgIHJldHVybiBbZWRnZUFuY2VzdG9yLmRhdGEgKyAnJ107XG4gICAgfVxuICAgIGlmIChlZGdlLnApXG4gICAgICByZXR1cm4gWy4uLnRoaXMuX3ByaW50UGFyZW50VW50aWwoZWRnZS5wWzBdLCBlZGdlQW5jZXN0b3IpLCBlZGdlLmRhdGEgKyAnJ107XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIFsnPyAtPiAnLCBlZGdlLmRhdGEgKyAnJ107XG4gIH1cblxuICBwcml2YXRlIHZpc2l0VmVydGV4KHU6IFZlcnRleDxUPikge1xuICAgIHUuZCA9ICsrdGhpcy50aW1lO1xuICAgIHUuY29sb3IgPSBDb2xvci5ncmF5O1xuICAgIGZvciAoY29uc3QgdkRhdGEgb2YgdGhpcy5hZGphY2VuY3lPZih1LmRhdGEpKSB7XG4gICAgICBjb25zdCB2ID0gdGhpcy52ZXJ0ZXhPZih2RGF0YSk7XG4gICAgICBpZiAodi5jb2xvciA9PT0gQ29sb3Iud2hpdGUpIHtcbiAgICAgICAgdi5wID0gW3VdO1xuICAgICAgICB0aGlzLnZpc2l0VmVydGV4KHYpO1xuICAgICAgfSBlbHNlIGlmICh2LmNvbG9yID09PSBDb2xvci5ncmF5KSB7XG4gICAgICAgIHRoaXMuYmFja0VkZ2VzLnB1c2goW3UsIHZdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2LnAgPT0gbnVsbClcbiAgICAgICAgICB2LnAgPSBbXTtcbiAgICAgICAgdi5wLnB1c2godSk7XG4gICAgICB9XG4gICAgfVxuICAgIHUuY29sb3IgPSBDb2xvci5ibGFjaztcbiAgICB1LmYgPSArK3RoaXMudGltZTtcbiAgfVxufVxuIl19