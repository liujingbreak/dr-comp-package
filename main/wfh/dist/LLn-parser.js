"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTextParser = exports.LookAhead = exports.parser = exports.Token = exports.Chunk = exports.listTokens = exports.createStringParser = void 0;
const util_1 = __importDefault(require("util"));
/**
 * T - Token Types
 * AST - type of returned AST object
 */
function createStringParser(parserName, lexer, grammar) {
    return function (input) {
        const p = parser(parserName, lexer, grammar);
        p.write(input);
        p.end();
        return p.getResult();
    };
}
exports.createStringParser = createStringParser;
/**
 * Help for testing result of lexer function
 * @param lexer
 */
function listTokens(debugName, input, lexer) {
    const lexerLa = new LookAhead(debugName, () => {
        lexerLa._write(input);
        lexerLa._final();
    });
    const tokens = [];
    lexer(lexerLa, {
        emit() {
            const token = strChunk2Token(lexerLa.currChunk);
            token.close(lexerLa.position);
            tokens.push(token);
        },
        end() { }
    });
    return tokens;
}
exports.listTokens = listTokens;
class Chunk {
    constructor(pos, line, col) {
        this.pos = pos;
        this.line = line;
        this.col = col;
        this.values = [];
        this.isClosed = false;
        this.trackValue = true;
    }
    close(position) {
        this.isClosed = true;
        this.end = position;
        return this;
    }
}
exports.Chunk = Chunk;
class Token extends Chunk {
}
exports.Token = Token;
function parser(parserName, lexer, grammar, chunkConverter) {
    let isString;
    const lexerLa = new LookAhead(parserName + ' lexer');
    const tokenEmitter = {
        emit() {
            if (isString === undefined && lexerLa.currChunk.values != null)
                isString = typeof lexerLa.currChunk.values[0] === 'string';
            const token = chunkConverter ? chunkConverter(lexerLa.currChunk) :
                (isString ?
                    strChunk2Token(lexerLa.currChunk) :
                    lexerLa.currChunk);
            tokenLa._write([token]);
            token.close(lexerLa.position);
        },
        end() {
            tokenLa._final();
        }
    };
    const tokenLa = new LookAhead(parserName + ' grammar', function () {
        lexer(lexerLa, tokenEmitter);
    });
    return {
        write: lexerLa._write.bind(lexerLa),
        end: lexerLa._final.bind(lexerLa),
        getResult() {
            return grammar(tokenLa);
        }
    };
}
exports.parser = parser;
class LookAhead {
    constructor(name, onDrain) {
        this.name = name;
        this.onDrain = onDrain;
        this.line = 1;
        this.column = 1;
        this.currPos = 0;
        this.cacheStartPos = 0;
        this.cached = [];
    }
    _write(values) {
        for (const v of values)
            this.cached.push(v);
    }
    _final() {
        this._write([null]);
    }
    get position() {
        return this.currPos;
    }
    /**
       * look ahead for 1 character
       * @param num default is 1
       * @return null if EOF is reached
       */
    la(num = 1) {
        const readPos = this.currPos + num - 1;
        return this.read(readPos);
    }
    advance(count = 1) {
        // return new Promise(resolve => {
        let currValue;
        let i = 0;
        while (i++ < count) {
            const value = this.la(1);
            if (value == null) {
                this.throwError('Unexpect EOF'); // , stack);
                break;
            }
            this.currPos++;
            this.column++;
            if (value === '\n') {
                this.line++;
                this.column = 1;
            }
            if (this.currPos - this.cacheStartPos > 0x100000) {
                this.cached.splice(0, 0x100000);
                this.cacheStartPos += 0x100000;
            }
            if (this.currChunk && !this.currChunk.isClosed && this.currChunk.trackValue) {
                this.currChunk.values.push(value);
            }
            currValue = value;
        }
        this.lastConsumed = currValue;
        return currValue;
    }
    isNext(...values) {
        return this.isNextWith(values);
    }
    /**
       * Same as `return la(1) === values[0] && la(2) === values[1]...`
       * @param values lookahead string or tokens
       */
    isNextWith(values, isEqual = (a, b) => a === b) {
        let compareTo;
        let compareFn;
        compareTo = values;
        compareFn = isEqual;
        let i = 0;
        const l = compareTo.length;
        while (true) {
            if (i === l)
                return true;
            const next = this.la(i + 1);
            if (next == null)
                return false; // EOF
            else if (!compareFn(next, compareTo[i]))
                return false;
            i++;
        }
    }
    assertAdvance(...values) {
        return this.assertAdvanceWith(values);
    }
    assertAdvanceWith(values, isEqual = (a, b) => a === b) {
        let compareTo;
        let compareFn;
        compareTo = values;
        compareFn = isEqual;
        let i = 0;
        const l = compareTo.length;
        while (true) {
            if (i === l)
                return true;
            const next = this.advance(i + 1);
            if (next == null)
                this.throwError('EOF', new Error().stack); // EOF
            else if (!compareFn(next, compareTo[i]))
                this.throwError(util_1.default.inspect(next), new Error().stack, compareTo[i] + '');
            i++;
        }
    }
    throwError(unexpected = 'End-of-stream', stack, expect) {
        // eslint-disable-next-line max-len
        throw new Error(`In ${this.name} unexpected ${JSON.stringify(unexpected)}` +
            (expect ? `(expecting "${expect}")` : '') +
            `at ${this.getCurrentPosInfo()}, ${stack ? 'previous stack:' + stack : ''}`);
    }
    getCurrentPosInfo() {
        return `offset ${this.currPos} [${this.line}:${this.column}]`;
    }
    startChunk(type, trackValue = true) {
        if (this.currChunk && !this.currChunk.isClosed)
            this.currChunk.close(this.currPos);
        this.currChunk = new Chunk(this.currPos, this.line, this.column);
        this.currChunk.trackValue = trackValue;
        this.currChunk.type = type;
        return this.currChunk;
    }
    closeChunk() {
        return this.currChunk.close(this.currPos);
    }
    /**
       * Do not read postion less than 0
       * @param pos
       */
    read(pos) {
        const cacheOffset = pos - this.cacheStartPos;
        if (cacheOffset < 0) {
            throw new Error(`Can not read behind stream cache, at position: ${pos}`);
        }
        while (true) {
            if (cacheOffset < this.cached.length) {
                return this.cached[cacheOffset];
            }
            else {
                if (this.onDrain) {
                    this.onDrain();
                    continue;
                }
                throw new Error(`The internal buffer is drained early at ${pos}`);
                // this.waitForPos = pos;
                // const err = new WaitError();
                // throw err;
                // return new Promise(resolve => {
                //   this.readResolve = resolve;
                // });
            }
        }
    }
}
exports.LookAhead = LookAhead;
function strChunk2Token(chunk) {
    if (chunk.values) {
        chunk.text = chunk.values.join('');
        delete chunk.values;
    }
    return chunk;
}
/**
 * Convenient function for creating a text based parser,
 * you only need to define Token types, lexer function, grammar function
 */
function createTextParser() {
}
exports.createTextParser = createTextParser;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTExuLXBhcnNlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3RzL0xMbi1wYXJzZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsZ0RBQXdCO0FBRXhCOzs7R0FHRztBQUNILFNBQWdCLGtCQUFrQixDQUFTLFVBQWtCLEVBQUUsS0FBdUIsRUFDcEYsT0FBK0I7SUFFL0IsT0FBTyxVQUFTLEtBQWE7UUFDM0IsTUFBTSxDQUFDLEdBQUcsTUFBTSxDQUFDLFVBQVUsRUFBRSxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDN0MsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNmLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNSLE9BQU8sQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUFDO0lBQ3ZCLENBQUMsQ0FBQztBQUNKLENBQUM7QUFURCxnREFTQztBQUVEOzs7R0FHRztBQUNILFNBQWdCLFVBQVUsQ0FBSSxTQUFpQixFQUFFLEtBQWEsRUFBRSxLQUF1QjtJQUNyRixNQUFNLE9BQU8sR0FBRyxJQUFJLFNBQVMsQ0FBWSxTQUFTLEVBQUUsR0FBRyxFQUFFO1FBQ3ZELE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDdEIsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDO0lBQ25CLENBQUMsQ0FBQyxDQUFDO0lBRUgsTUFBTSxNQUFNLEdBQUcsRUFBZ0IsQ0FBQztJQUNoQyxLQUFLLENBQUMsT0FBTyxFQUFFO1FBQ2IsSUFBSTtZQUNGLE1BQU0sS0FBSyxHQUFHLGNBQWMsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDaEQsS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDOUIsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNyQixDQUFDO1FBQ0QsR0FBRyxLQUFJLENBQUM7S0FDVCxDQUFDLENBQUM7SUFFSCxPQUFP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VyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDO1FBQzdDLElBQUksV0FBVyxHQUFHLENBQUMsRUFBRTtZQUNuQixNQUFNLElBQUksS0FBSyxDQUFDLGtEQUFrRCxHQUFHLEVBQUUsQ0FBQyxDQUFDO1NBQzFFO1FBQ0QsT0FBTyxJQUFJLEVBQUU7WUFDWCxJQUFJLFdBQVcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRTtnQkFDcEMsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2FBQ2pDO2lCQUFNO2dCQUNMLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRTtvQkFDaEIsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO29CQUNmLFNBQVM7aUJBQ1Y7Z0JBQ0QsTUFBTSxJQUFJLEtBQUssQ0FBQywyQ0FBMkMsR0FBRyxFQUFFLENBQUMsQ0FBQztnQkFDbEUseUJBQXlCO2dCQUN6QiwrQkFBK0I7Z0JBQy9CLGFBQWE7Z0JBQ2Isa0NBQWtDO2dCQUNsQyxnQ0FBZ0M7Z0JBQ2hDLE1BQU07YUFDUDtTQUNGO0lBQ0gsQ0FBQztDQUNGO0FBdktELDhCQXVLQztBQUVELFNBQVMsY0FBYyxDQUFJLEtBQXVCO0lBQ2hELElBQUksS0FBSyxDQUFDLE1BQU0sRUFBRTtRQUNmLEtBQWtCLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ2pELE9BQU8sS0FBSyxDQUFDLE1BQU0sQ0FBQztLQUNyQjtJQUNELE9BQU8sS0FBaUIsQ0FBQztBQUMzQixDQUFDO0FBRUQ7OztHQUdHO0FBQ0gsU0FBZ0IsZ0JBQWdCO0FBRWhDLENBQUM7QUFGRCw0Q0FFQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB1dGlsIGZyb20gJ3V0aWwnO1xuXG4vKipcbiAqIFQgLSBUb2tlbiBUeXBlc1xuICogQVNUIC0gdHlwZSBvZiByZXR1cm5lZCBBU1Qgb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdHJpbmdQYXJzZXI8VCwgQVNUPihwYXJzZXJOYW1lOiBzdHJpbmcsIGxleGVyOiBMZXhlcjxzdHJpbmcsIFQ+LFxuICBncmFtbWFyOiBHcmFtbWFyPFRva2VuPFQ+LCBBU1Q+KSB7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGlucHV0OiBzdHJpbmcpIHtcbiAgICBjb25zdCBwID0gcGFyc2VyKHBhcnNlck5hbWUsIGxleGVyLCBncmFtbWFyKTtcbiAgICBwLndyaXRlKGlucHV0KTtcbiAgICBwLmVuZCgpO1xuICAgIHJldHVybiBwLmdldFJlc3VsdCgpO1xuICB9O1xufVxuXG4vKipcbiAqIEhlbHAgZm9yIHRlc3RpbmcgcmVzdWx0IG9mIGxleGVyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbGV4ZXIgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0VG9rZW5zPFQ+KGRlYnVnTmFtZTogc3RyaW5nLCBpbnB1dDogc3RyaW5nLCBsZXhlcjogTGV4ZXI8c3RyaW5nLCBUPik6IFRva2VuPFQ+W10ge1xuICBjb25zdCBsZXhlckxhID0gbmV3IExvb2tBaGVhZDxzdHJpbmcsIFQ+KGRlYnVnTmFtZSwgKCkgPT4ge1xuICAgIGxleGVyTGEuX3dyaXRlKGlucHV0KTtcbiAgICBsZXhlckxhLl9maW5hbCgpO1xuICB9KTtcblxuICBjb25zdCB0b2tlbnMgPSBbXSBhcyBUb2tlbjxUPltdO1xuICBsZXhlcihsZXhlckxhLCB7XG4gICAgZW1pdCgpIHtcbiAgICAgIGNvbnN0IHRva2VuID0gc3RyQ2h1bmsyVG9rZW4obGV4ZXJMYS5jdXJyQ2h1bmspO1xuICAgICAgdG9rZW4uY2xvc2UobGV4ZXJMYS5wb3NpdGlvbik7XG4gICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgfSxcbiAgICBlbmQoKSB7fVxuICB9KTtcblxuICByZXR1cm4gdG9rZW5zO1xufVxuZXhwb3J0IGNsYXNzIENodW5rPFYsIFQ+IHtcbiAgdHlwZTogVDtcbiAgdmFsdWVzPzogVltdID0gW107XG4gIGVuZDogbnVtYmVyO1xuICBpc0Nsb3NlZCA9IGZhbHNlO1xuICB0cmFja1ZhbHVlID0gdHJ1ZTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgcG9zOiBudW1iZXIsIHB1YmxpYyBsaW5lOiBudW1iZXIsIHB1YmxpYyBjb2w6IG51bWJlclxuICApIHt9XG5cbiAgY2xvc2UocG9zaXRpb246IG51bWJlcikge1xuICAgIHRoaXMuaXNDbG9zZWQgPSB0cnVlO1xuICAgIHRoaXMuZW5kID0gcG9zaXRpb247XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFRva2VuPFQ+IGV4dGVuZHMgQ2h1bms8c3RyaW5nLCBUPiB7XG4gIHRleHQ6IHN0cmluZztcbn1cblxuLyoqXG4gKiAgViBpcyB0eXBlIG9mIGVhY2ggYGNoYXJhY3RlcmAsIGUuZy4gc3RyaW5nLCBudW1iZXJcbiAqICBUIGlzIFRva2VuIFR5cGUsIGUuZy4gc3RyaW5nIG9yIGEgZW51bVxuICogIEMgY291bGQgYmUgb21pdFxuICovXG5leHBvcnQgdHlwZSBMZXhlcjxWLFQsIEMgZXh0ZW5kcyBDaHVuazxWLCBUPiA9IENodW5rPFYsIFQ+PiA9XG4gIChsYTogTG9va0FoZWFkPFYsVD4sIGVtaXR0ZXI6IFRva2VuRW1pdHRlcjxWLCBULCBDPikgPT4gdm9pZDtcbmV4cG9ydCB0eXBlIEdyYW1tYXI8QywgQT4gPSAodG9rZW5MYTogTG9va0FoZWFkPEM+KSA9PiBBO1xuXG5pbnRlcmZhY2UgVG9rZW5FbWl0dGVyPFYsIFQsIEM+IHtcbiAgZW1pdCgpOiB2b2lkO1xuICBlbmQoKTogdm9pZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlcjxWLCBULCBDIGV4dGVuZHMgQ2h1bms8ViwgVD4sIEE+KHBhcnNlck5hbWU6IHN0cmluZyxcbiAgbGV4ZXI6IExleGVyPFYsIFQsIEM+LFxuICBncmFtbWFyOiBHcmFtbWFyPEMsIEE+LFxuICBjaHVua0NvbnZlcnRlcj86IChjaHVuazogQ2h1bms8ViwgVD4pID0+IEMpOlxuICB7XG4gICAgd3JpdGU6IExvb2tBaGVhZDxWLCBUPlsnX3dyaXRlJ107XG4gICAgZW5kOiBMb29rQWhlYWQ8ViwgVD5bJ19maW5hbCddO1xuICAgIGdldFJlc3VsdDogKCkgPT4gQTtcbiAgfSB7XG5cbiAgbGV0IGlzU3RyaW5nOiBib29sZWFuO1xuICBjb25zdCBsZXhlckxhID0gbmV3IExvb2tBaGVhZDxWLCBUPihwYXJzZXJOYW1lKyAnIGxleGVyJyk7XG4gIGNvbnN0IHRva2VuRW1pdHRlcjogVG9rZW5FbWl0dGVyPFYsIFQsIEM+ID0ge1xuICAgIGVtaXQoKSB7XG4gICAgICBpZiAoaXNTdHJpbmcgPT09IHVuZGVmaW5lZCAmJiBsZXhlckxhLmN1cnJDaHVuay52YWx1ZXMgIT0gbnVsbClcbiAgICAgICAgaXNTdHJpbmcgPSB0eXBlb2YgbGV4ZXJMYS5jdXJyQ2h1bmsudmFsdWVzWzBdID09PSAnc3RyaW5nJztcbiAgICAgIGNvbnN0IHRva2VuOiBDID0gY2h1bmtDb252ZXJ0ZXIgPyBjaHVua0NvbnZlcnRlcihsZXhlckxhLmN1cnJDaHVuaykgOlxuICAgICAgICAoaXNTdHJpbmcgP1xuICAgICAgICAgIHN0ckNodW5rMlRva2VuKGxleGVyTGEuY3VyckNodW5rIGFzIHVua25vd24gYXMgQ2h1bms8c3RyaW5nLCBUPikgYXMgdW5rbm93biBhcyBDIDpcbiAgICAgICAgICBsZXhlckxhLmN1cnJDaHVuayBhcyBDKTtcbiAgICAgIHRva2VuTGEuX3dyaXRlKFt0b2tlbl0pO1xuICAgICAgdG9rZW4uY2xvc2UobGV4ZXJMYS5wb3NpdGlvbik7XG4gICAgfSxcbiAgICBlbmQoKSB7XG4gICAgICB0b2tlbkxhLl9maW5hbCgpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdG9rZW5MYSA9IG5ldyBMb29rQWhlYWQ8Qz4ocGFyc2VyTmFtZSArICcgZ3JhbW1hcicsIGZ1bmN0aW9uKCkge1xuICAgIGxleGVyKGxleGVyTGEsIHRva2VuRW1pdHRlcik7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHdyaXRlOiBsZXhlckxhLl93cml0ZS5iaW5kKGxleGVyTGEpIGFzIExvb2tBaGVhZDxWLCBUPlsnX3dyaXRlJ10sXG4gICAgZW5kOiBsZXhlckxhLl9maW5hbC5iaW5kKGxleGVyTGEpIGFzIExvb2tBaGVhZDxWLCBUPlsnX2ZpbmFsJ10sXG4gICAgZ2V0UmVzdWx0KCkge1xuICAgICAgcmV0dXJuIGdyYW1tYXIodG9rZW5MYSk7XG4gICAgfVxuICB9O1xufVxuXG5cbmV4cG9ydCBjbGFzcyBMb29rQWhlYWQ8ViwgVCA9IHZvaWQ+IHtcbiAgc3RhdGljIFdBSVRfRVJST1I6ICdXQUlUX0VSUk9SJztcbiAgY2FjaGVkOiBBcnJheTxWfG51bGw+O1xuICBsaW5lID0gMTtcbiAgY29sdW1uID0gMTtcbiAgbGFzdENvbnN1bWVkOiBWO1xuICBjdXJyQ2h1bms6IENodW5rPFYsIFQ+O1xuXG4gIHByaXZhdGUgY3VyclBvcyA9IDA7XG4gIHByaXZhdGUgY2FjaGVTdGFydFBvcyA9IDA7XG5cbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIG5hbWU6IHN0cmluZywgcHJpdmF0ZSBvbkRyYWluPzogKHRoaXM6IExvb2tBaGVhZDxWLCBUPikgPT4gdm9pZCkge1xuICAgIHRoaXMuY2FjaGVkID0gW107XG4gIH1cblxuICBfd3JpdGUodmFsdWVzOiBJdGVyYWJsZTxWfG51bGw+KSB7XG4gICAgZm9yIChjb25zdCB2IG9mIHZhbHVlcylcbiAgICAgIHRoaXMuY2FjaGVkLnB1c2godik7XG4gIH1cblxuICBfZmluYWwoKSB7XG4gICAgdGhpcy5fd3JpdGUoW251bGxdKTtcbiAgfVxuXG4gIGdldCBwb3NpdGlvbigpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmN1cnJQb3M7XG4gIH1cblxuICAvKipcblx0ICogbG9vayBhaGVhZCBmb3IgMSBjaGFyYWN0ZXJcblx0ICogQHBhcmFtIG51bSBkZWZhdWx0IGlzIDFcblx0ICogQHJldHVybiBudWxsIGlmIEVPRiBpcyByZWFjaGVkXG5cdCAqL1xuICBsYShudW0gPSAxKTogViB8IG51bGwge1xuICAgIGNvbnN0IHJlYWRQb3MgPSB0aGlzLmN1cnJQb3MgKyBudW0gLSAxO1xuICAgIHJldHVybiB0aGlzLnJlYWQocmVhZFBvcyk7XG4gIH1cblxuICBhZHZhbmNlKGNvdW50ID0gMSk6IFYge1xuICAgIC8vIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBsZXQgY3VyclZhbHVlOiBWO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSsrIDwgY291bnQpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5sYSgxKTtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMudGhyb3dFcnJvcignVW5leHBlY3QgRU9GJyk7IC8vICwgc3RhY2spO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRoaXMuY3VyclBvcysrO1xuICAgICAgdGhpcy5jb2x1bW4rKztcbiAgICAgIGlmICgodmFsdWUgYXMgYW55KSA9PT0gJ1xcbicpIHtcbiAgICAgICAgdGhpcy5saW5lKys7XG4gICAgICAgIHRoaXMuY29sdW1uID0gMTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmN1cnJQb3MgLSB0aGlzLmNhY2hlU3RhcnRQb3MgPiAweDEwMDAwMCkge1xuICAgICAgICB0aGlzLmNhY2hlZC5zcGxpY2UoMCwgMHgxMDAwMDApO1xuICAgICAgICB0aGlzLmNhY2hlU3RhcnRQb3MgKz0gMHgxMDAwMDA7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jdXJyQ2h1bmsgJiYgIXRoaXMuY3VyckNodW5rLmlzQ2xvc2VkICYmIHRoaXMuY3VyckNodW5rLnRyYWNrVmFsdWUpIHtcbiAgICAgICAgdGhpcy5jdXJyQ2h1bmsudmFsdWVzIS5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGN1cnJWYWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICB0aGlzLmxhc3RDb25zdW1lZCA9IGN1cnJWYWx1ZSE7XG4gICAgcmV0dXJuIGN1cnJWYWx1ZSE7XG4gIH1cblxuICBpc05leHQoLi4udmFsdWVzOiBWW10pIHtcbiAgICByZXR1cm4gdGhpcy5pc05leHRXaXRoKHZhbHVlcyk7XG4gIH1cbiAgLyoqXG5cdCAqIFNhbWUgYXMgYHJldHVybiBsYSgxKSA9PT0gdmFsdWVzWzBdICYmIGxhKDIpID09PSB2YWx1ZXNbMV0uLi5gXG5cdCAqIEBwYXJhbSB2YWx1ZXMgbG9va2FoZWFkIHN0cmluZyBvciB0b2tlbnNcblx0ICovXG4gIGlzTmV4dFdpdGg8Qz4odmFsdWVzOiBDW10sIGlzRXF1YWwgPSAoYTogViwgYjogQykgPT4gYSBhcyBhbnkgPT09IGIpOiBib29sZWFuIHtcbiAgICBsZXQgY29tcGFyZVRvOiBDW118IHN0cmluZztcbiAgICBsZXQgY29tcGFyZUZuOiAoLi4uYXJnOiBhbnlbXSkgPT4gYm9vbGVhbjtcbiAgICBjb21wYXJlVG8gPSB2YWx1ZXM7XG4gICAgY29tcGFyZUZuID0gaXNFcXVhbDtcbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3QgbCA9IGNvbXBhcmVUby5sZW5ndGg7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChpID09PSBsKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmxhKGkgKyAxKTtcbiAgICAgIGlmIChuZXh0ID09IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gRU9GXG4gICAgICBlbHNlIGlmICghY29tcGFyZUZuKG5leHQsIGNvbXBhcmVUb1tpXSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGkrKztcbiAgICB9XG4gIH1cblxuICBhc3NlcnRBZHZhbmNlKC4uLnZhbHVlczogVltdKSB7XG4gICAgcmV0dXJuIHRoaXMuYXNzZXJ0QWR2YW5jZVdpdGgodmFsdWVzKTtcbiAgfVxuXG4gIGFzc2VydEFkdmFuY2VXaXRoPEM+KHZhbHVlczogQ1tdLCBpc0VxdWFsID0gKGE6IFYsIGI6IEMpID0+IGEgYXMgYW55ID09PSBiKSB7XG4gICAgbGV0IGNvbXBhcmVUbzogQ1tdfCBzdHJpbmc7XG4gICAgbGV0IGNvbXBhcmVGbjogKC4uLmFyZzogYW55W10pID0+IGJvb2xlYW47XG4gICAgY29tcGFyZVRvID0gdmFsdWVzO1xuICAgIGNvbXBhcmVGbiA9IGlzRXF1YWw7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IGwgPSBjb21wYXJlVG8ubGVuZ3RoO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoaSA9PT0gbClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjb25zdCBuZXh0ID0gdGhpcy5hZHZhbmNlKGkgKyAxKTtcbiAgICAgIGlmIChuZXh0ID09IG51bGwpXG4gICAgICAgIHRoaXMudGhyb3dFcnJvcignRU9GJywgbmV3IEVycm9yKCkuc3RhY2spOyAvLyBFT0ZcbiAgICAgIGVsc2UgaWYgKCFjb21wYXJlRm4obmV4dCwgY29tcGFyZVRvW2ldKSlcbiAgICAgICAgdGhpcy50aHJvd0Vycm9yKHV0aWwuaW5zcGVjdChuZXh0KSwgbmV3IEVycm9yKCkuc3RhY2ssIGNvbXBhcmVUb1tpXSArICcnKTtcbiAgICAgIGkrKztcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHVuZXhwZWN0ZWQgPSAnRW5kLW9mLXN0cmVhbScsIHN0YWNrPzogYW55LCBleHBlY3Q/OiBzdHJpbmcpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgIHRocm93IG5ldyBFcnJvcihgSW4gJHt0aGlzLm5hbWV9IHVuZXhwZWN0ZWQgJHtKU09OLnN0cmluZ2lmeSh1bmV4cGVjdGVkKX1gK1xuICAgIChleHBlY3QgPyBgKGV4cGVjdGluZyBcIiR7ZXhwZWN0fVwiKWAgOiAnJykgK1xuICAgIGBhdCAke3RoaXMuZ2V0Q3VycmVudFBvc0luZm8oKX0sICR7c3RhY2sgPyAncHJldmlvdXMgc3RhY2s6JyArIHN0YWNrIDogJyd9YCk7XG4gIH1cblxuICBnZXRDdXJyZW50UG9zSW5mbygpOiBzdHJpbmcge1xuICAgIHJldHVybiBgb2Zmc2V0ICR7dGhpcy5jdXJyUG9zfSBbJHt0aGlzLmxpbmV9OiR7dGhpcy5jb2x1bW59XWA7XG4gIH1cblxuICBzdGFydENodW5rKHR5cGU6IFQsIHRyYWNrVmFsdWUgPSB0cnVlKSB7XG4gICAgaWYgKHRoaXMuY3VyckNodW5rICYmICF0aGlzLmN1cnJDaHVuay5pc0Nsb3NlZClcbiAgICAgIHRoaXMuY3VyckNodW5rLmNsb3NlKHRoaXMuY3VyclBvcyk7XG4gICAgdGhpcy5jdXJyQ2h1bmsgPSBuZXcgQ2h1bms8ViwgVD4odGhpcy5jdXJyUG9zLCB0aGlzLmxpbmUsIHRoaXMuY29sdW1uKTtcbiAgICB0aGlzLmN1cnJDaHVuay50cmFja1ZhbHVlID0gdHJhY2tWYWx1ZTtcbiAgICB0aGlzLmN1cnJDaHVuay50eXBlID0gdHlwZTtcbiAgICByZXR1cm4gdGhpcy5jdXJyQ2h1bms7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2xvc2VDaHVuaygpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyQ2h1bmsuY2xvc2UodGhpcy5jdXJyUG9zKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBEbyBub3QgcmVhZCBwb3N0aW9uIGxlc3MgdGhhbiAwXG5cdCAqIEBwYXJhbSBwb3MgXG5cdCAqL1xuICBwcml2YXRlIHJlYWQocG9zOiBudW1iZXIpOiBWIHwgbnVsbCB7XG4gICAgY29uc3QgY2FjaGVPZmZzZXQgPSBwb3MgLSB0aGlzLmNhY2hlU3RhcnRQb3M7XG4gICAgaWYgKGNhY2hlT2Zmc2V0IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4gbm90IHJlYWQgYmVoaW5kIHN0cmVhbSBjYWNoZSwgYXQgcG9zaXRpb246ICR7cG9zfWApO1xuICAgIH1cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGNhY2hlT2Zmc2V0IDwgdGhpcy5jYWNoZWQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlZFtjYWNoZU9mZnNldF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5vbkRyYWluKSB7XG4gICAgICAgICAgdGhpcy5vbkRyYWluKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgaW50ZXJuYWwgYnVmZmVyIGlzIGRyYWluZWQgZWFybHkgYXQgJHtwb3N9YCk7XG4gICAgICAgIC8vIHRoaXMud2FpdEZvclBvcyA9IHBvcztcbiAgICAgICAgLy8gY29uc3QgZXJyID0gbmV3IFdhaXRFcnJvcigpO1xuICAgICAgICAvLyB0aHJvdyBlcnI7XG4gICAgICAgIC8vIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgLy8gICB0aGlzLnJlYWRSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgLy8gfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0ckNodW5rMlRva2VuPFQ+KGNodW5rOiBDaHVuazxzdHJpbmcsIFQ+KSB7XG4gIGlmIChjaHVuay52YWx1ZXMpIHtcbiAgICAoY2h1bmsgYXMgVG9rZW48VD4pLnRleHQgPSBjaHVuay52YWx1ZXMuam9pbignJyk7XG4gICAgZGVsZXRlIGNodW5rLnZhbHVlcztcbiAgfVxuICByZXR1cm4gY2h1bmsgYXMgVG9rZW48VD47XG59XG5cbi8qKlxuICogQ29udmVuaWVudCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSB0ZXh0IGJhc2VkIHBhcnNlcixcbiAqIHlvdSBvbmx5IG5lZWQgdG8gZGVmaW5lIFRva2VuIHR5cGVzLCBsZXhlciBmdW5jdGlvbiwgZ3JhbW1hciBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVGV4dFBhcnNlcigpIHtcblxufVxuIl19