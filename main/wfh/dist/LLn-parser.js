"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTextParser = exports.LookAhead = exports.parser = exports.Token = exports.Chunk = exports.listTokens = exports.createStringParser = void 0;
const util_1 = __importDefault(require("util"));
/**
 * T - Token Types
 * AST - type of returned AST object
 */
function createStringParser(parserName, lexer, grammar) {
    return function (input) {
        const p = parser(parserName, lexer, grammar);
        p.write(input);
        p.end();
        return p.getResult();
    };
}
exports.createStringParser = createStringParser;
/**
 * Help for testing result of lexer function
 * @param lexer
 */
function listTokens(debugName, input, lexer) {
    const lexerLa = new LookAhead(debugName, () => {
        lexerLa._write(input);
        lexerLa._final();
    });
    const tokens = [];
    lexer(lexerLa, {
        emit() {
            const token = strChunk2Token(lexerLa.currChunk);
            token.close(lexerLa.position);
            tokens.push(token);
        },
        end() { }
    });
    return tokens;
}
exports.listTokens = listTokens;
class Chunk {
    constructor(pos, line, col) {
        this.pos = pos;
        this.line = line;
        this.col = col;
        this.values = [];
        this.isClosed = false;
        this.trackValue = true;
    }
    close(position) {
        this.isClosed = true;
        this.end = position;
        return this;
    }
}
exports.Chunk = Chunk;
class Token extends Chunk {
}
exports.Token = Token;
function parser(parserName, lexer, grammar, chunkConverter) {
    let isString;
    const lexerLa = new LookAhead(parserName + ' lexer');
    const tokenEmitter = {
        emit() {
            if (isString === undefined && lexerLa.currChunk.values != null)
                isString = typeof lexerLa.currChunk.values[0] === 'string';
            const token = chunkConverter ? chunkConverter(lexerLa.currChunk) :
                (isString ?
                    strChunk2Token(lexerLa.currChunk) :
                    lexerLa.currChunk);
            tokenLa._write([token]);
            token.close(lexerLa.position);
        },
        end() {
            tokenLa._final();
        }
    };
    const tokenLa = new LookAhead(parserName + ' grammar', function () {
        lexer(lexerLa, tokenEmitter);
    });
    return {
        write: lexerLa._write.bind(lexerLa),
        end: lexerLa._final.bind(lexerLa),
        getResult() {
            return grammar(tokenLa);
        }
    };
}
exports.parser = parser;
class LookAhead {
    constructor(name, onDrain) {
        this.name = name;
        this.onDrain = onDrain;
        this.line = 1;
        this.column = 1;
        this.currPos = 0;
        this.cacheStartPos = 0;
        this.cached = [];
    }
    _write(values) {
        for (const v of values)
            this.cached.push(v);
    }
    _final() {
        this._write([null]);
    }
    get position() {
        return this.currPos;
    }
    /**
       * look ahead for 1 character
       * @param num default is 1
       * @return null if EOF is reached
       */
    la(num = 1) {
        const readPos = this.currPos + num - 1;
        return this.read(readPos);
    }
    advance(count = 1) {
        // return new Promise(resolve => {
        let currValue;
        let i = 0;
        while (i++ < count) {
            const value = this.la(1);
            if (value == null) {
                this.throwError('Unexpect EOF'); // , stack);
                break;
            }
            this.currPos++;
            this.column++;
            if (value === '\n') {
                this.line++;
                this.column = 1;
            }
            if (this.currPos - this.cacheStartPos > 0x100000) {
                this.cached.splice(0, 0x100000);
                this.cacheStartPos += 0x100000;
            }
            if (this.currChunk && !this.currChunk.isClosed && this.currChunk.trackValue) {
                this.currChunk.values.push(value);
            }
            currValue = value;
        }
        this.lastConsumed = currValue;
        return currValue;
    }
    isNext(...values) {
        return this.isNextWith(values);
    }
    /**
       * Same as `return la(1) === values[0] && la(2) === values[1]...`
       * @param values lookahead string or tokens
       */
    isNextWith(values, isEqual = (a, b) => a === b) {
        let compareTo;
        let compareFn;
        compareTo = values;
        compareFn = isEqual;
        let i = 0;
        const l = compareTo.length;
        while (true) {
            if (i === l)
                return true;
            const next = this.la(i + 1);
            if (next == null)
                return false; // EOF
            else if (!compareFn(next, compareTo[i]))
                return false;
            i++;
        }
    }
    assertAdvance(...values) {
        return this.assertAdvanceWith(values);
    }
    assertAdvanceWith(values, isEqual = (a, b) => a === b) {
        let compareTo;
        let compareFn;
        compareTo = values;
        compareFn = isEqual;
        let i = 0;
        const l = compareTo.length;
        while (true) {
            if (i === l)
                return true;
            const next = this.advance(i + 1);
            if (next == null)
                this.throwError('EOF', new Error().stack); // EOF
            else if (!compareFn(next, compareTo[i]))
                this.throwError(util_1.default.inspect(next), new Error().stack, compareTo[i] + '');
            i++;
        }
    }
    throwError(unexpected = 'End-of-stream', stack, expect) {
        // eslint-disable-next-line max-len
        throw new Error(`In ${this.name} unexpected ${JSON.stringify(unexpected)}` +
            (expect ? `(expecting "${expect}")` : '') +
            `at ${this.getCurrentPosInfo()}, ${stack ? 'previous stack:' + stack : ''}`);
    }
    getCurrentPosInfo() {
        return `offset ${this.currPos} [${this.line}:${this.column}]`;
    }
    startChunk(type, trackValue = true) {
        if (this.currChunk && !this.currChunk.isClosed)
            this.currChunk.close(this.currPos);
        this.currChunk = new Chunk(this.currPos, this.line, this.column);
        this.currChunk.trackValue = trackValue;
        this.currChunk.type = type;
        return this.currChunk;
    }
    closeChunk() {
        return this.currChunk.close(this.currPos);
    }
    /**
       * Do not read postion less than 0
       * @param pos
       */
    read(pos) {
        const cacheOffset = pos - this.cacheStartPos;
        if (cacheOffset < 0) {
            throw new Error(`Can not read behind stream cache, at position: ${pos}`);
        }
        while (true) {
            if (cacheOffset < this.cached.length) {
                return this.cached[cacheOffset];
            }
            else {
                if (this.onDrain) {
                    this.onDrain();
                    continue;
                }
                throw new Error(`The internal buffer is drained early at ${pos}`);
                // this.waitForPos = pos;
                // const err = new WaitError();
                // throw err;
                // return new Promise(resolve => {
                //   this.readResolve = resolve;
                // });
            }
        }
    }
}
exports.LookAhead = LookAhead;
function strChunk2Token(chunk) {
    if (chunk.values) {
        chunk.text = chunk.values.join('');
        delete chunk.values;
    }
    return chunk;
}
/**
 * Convenient function for creating a text based parser,
 * you only need to define Token types, lexer function, grammar function
 */
function createTextParser() {
}
exports.createTextParser = createTextParser;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTExuLXBhcnNlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3RzL0xMbi1wYXJzZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsZ0RBQXdCO0FBRXhCOzs7R0FHRztBQUNILFNBQWdCLGtCQUFrQixDQUFTLFVBQWtCLEVBQUUsS0FBdUIsRUFDcEYsT0FBK0I7SUFFL0IsT0FBTyxVQUFTLEtBQWE7UUFDM0IsTUFBTSxDQUFDLEdBQUcsTUFBTSxDQUFDLFVBQVUsRUFBRSxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDN0MsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNmLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNSLE9BQU8sQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUFDO0lBQ3ZCLENBQUMsQ0FBQztBQUNKLENBQUM7QUFURCxnREFTQztBQUVEOzs7R0FHRztBQUNILFNBQWdCLFVBQVUsQ0FBSSxTQUFpQixFQUFFLEtBQWEsRUFBRSxLQUF1QjtJQUNyRixNQUFNLE9BQU8sR0FBRyxJQUFJLFNBQVMsQ0FBWSxTQUFTLEVBQUUsR0FBRyxFQUFFO1FBQ3ZELE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDdEIsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDO0lBQ25CLENBQUMsQ0FBQyxDQUFDO0lBRUgsTUFBTSxNQUFNLEdBQUcsRUFBZ0IsQ0FBQztJQUNoQyxLQUFLLENBQUMsT0FBTyxFQUFFO1FBQ2IsSUFBSTtZQUNGLE1BQU0sS0FBSyxHQUFHLGNBQWMsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDaEQsS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDOUIsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNyQixDQUFDO1FBQ0QsR0FBRyxLQUFJLENBQUM7S0FDVCxDQUFDLENBQUM7SUFFSCxPQUFP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VyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDO1FBQzdDLElBQUksV0FBVyxHQUFHLENBQUMsRUFBRTtZQUNuQixNQUFNLElBQUksS0FBSyxDQUFDLGtEQUFrRCxHQUFHLEVBQUUsQ0FBQyxDQUFDO1NBQzFFO1FBQ0QsT0FBTyxJQUFJLEVBQUU7WUFDWCxJQUFJLFdBQVcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRTtnQkFDcEMsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2FBQ2pDO2lCQUFNO2dCQUNMLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRTtvQkFDaEIsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO29CQUNmLFNBQVM7aUJBQ1Y7Z0JBQ0QsTUFBTSxJQUFJLEtBQUssQ0FBQywyQ0FBMkMsR0FBRyxFQUFFLENBQUMsQ0FBQztnQkFDbEUseUJBQXlCO2dCQUN6QiwrQkFBK0I7Z0JBQy9CLGFBQWE7Z0JBQ2Isa0NBQWtDO2dCQUNsQyxnQ0FBZ0M7Z0JBQ2hDLE1BQU07YUFDUDtTQUNGO0lBQ0gsQ0FBQztDQUNGO0FBdktELDhCQXVLQztBQUVELFNBQVMsY0FBYyxDQUFJLEtBQXVCO0lBQ2hELElBQUksS0FBSyxDQUFDLE1BQU0sRUFBRTtRQUNmLEtBQWtCLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ2pELE9BQU8sS0FBSyxDQUFDLE1BQU0sQ0FBQztLQUNyQjtJQUNELE9BQU8sS0FBaUIsQ0FBQztBQUMzQixDQUFDO0FBRUQ7OztHQUdHO0FBQ0gsU0FBZ0IsZ0JBQWdCO0FBRWhDLENBQUM7QUFGRCw0Q0FFQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB1dGlsIGZyb20gJ3V0aWwnO1xuXG4vKipcbiAqIFQgLSBUb2tlbiBUeXBlc1xuICogQVNUIC0gdHlwZSBvZiByZXR1cm5lZCBBU1Qgb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdHJpbmdQYXJzZXI8VCwgQVNUPihwYXJzZXJOYW1lOiBzdHJpbmcsIGxleGVyOiBMZXhlcjxzdHJpbmcsIFQ+LFxuICBncmFtbWFyOiBHcmFtbWFyPFRva2VuPFQ+LCBBU1Q+KSB7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGlucHV0OiBzdHJpbmcpIHtcbiAgICBjb25zdCBwID0gcGFyc2VyKHBhcnNlck5hbWUsIGxleGVyLCBncmFtbWFyKTtcbiAgICBwLndyaXRlKGlucHV0KTtcbiAgICBwLmVuZCgpO1xuICAgIHJldHVybiBwLmdldFJlc3VsdCgpO1xuICB9O1xufVxuXG4vKipcbiAqIEhlbHAgZm9yIHRlc3RpbmcgcmVzdWx0IG9mIGxleGVyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbGV4ZXIgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0VG9rZW5zPFQ+KGRlYnVnTmFtZTogc3RyaW5nLCBpbnB1dDogc3RyaW5nLCBsZXhlcjogTGV4ZXI8c3RyaW5nLCBUPik6IFRva2VuPFQ+W10ge1xuICBjb25zdCBsZXhlckxhID0gbmV3IExvb2tBaGVhZDxzdHJpbmcsIFQ+KGRlYnVnTmFtZSwgKCkgPT4ge1xuICAgIGxleGVyTGEuX3dyaXRlKGlucHV0KTtcbiAgICBsZXhlckxhLl9maW5hbCgpO1xuICB9KTtcblxuICBjb25zdCB0b2tlbnMgPSBbXSBhcyBUb2tlbjxUPltdO1xuICBsZXhlcihsZXhlckxhLCB7XG4gICAgZW1pdCgpIHtcbiAgICAgIGNvbnN0IHRva2VuID0gc3RyQ2h1bmsyVG9rZW4obGV4ZXJMYS5jdXJyQ2h1bmspO1xuICAgICAgdG9rZW4uY2xvc2UobGV4ZXJMYS5wb3NpdGlvbik7XG4gICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgfSxcbiAgICBlbmQoKSB7fVxuICB9KTtcblxuICByZXR1cm4gdG9rZW5zO1xufVxuZXhwb3J0IGNsYXNzIENodW5rPFYsIFQ+IHtcbiAgdHlwZTogVDtcbiAgdmFsdWVzPzogVltdID0gW107XG4gIGVuZDogbnVtYmVyO1xuICBpc0Nsb3NlZCA9IGZhbHNlO1xuICB0cmFja1ZhbHVlID0gdHJ1ZTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgcG9zOiBudW1iZXIsIHB1YmxpYyBsaW5lOiBudW1iZXIsIHB1YmxpYyBjb2w6IG51bWJlclxuICApIHt9XG5cbiAgY2xvc2UocG9zaXRpb246IG51bWJlcikge1xuICAgIHRoaXMuaXNDbG9zZWQgPSB0cnVlO1xuICAgIHRoaXMuZW5kID0gcG9zaXRpb247XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFRva2VuPFQ+IGV4dGVuZHMgQ2h1bms8c3RyaW5nLCBUPiB7XG4gIHRleHQ6IHN0cmluZztcbn1cblxuLyoqXG4gKiAgViBpcyB0eXBlIG9mIGVhY2ggYGNoYXJhY3RlcmAsIGUuZy4gc3RyaW5nLCBudW1iZXJcbiAqICBUIGlzIFRva2VuIFR5cGUsIGUuZy4gc3RyaW5nIG9yIGEgZW51bVxuICogIEMgY291bGQgYmUgb21pdFxuICovXG5leHBvcnQgdHlwZSBMZXhlcjxWLCBULCBDIGV4dGVuZHMgQ2h1bms8ViwgVD4gPSBDaHVuazxWLCBUPj4gPVxuICAobGE6IExvb2tBaGVhZDxWLCBUPiwgZW1pdHRlcjogVG9rZW5FbWl0dGVyPFYsIFQsIEM+KSA9PiB2b2lkO1xuZXhwb3J0IHR5cGUgR3JhbW1hcjxDLCBBPiA9ICh0b2tlbkxhOiBMb29rQWhlYWQ8Qz4pID0+IEE7XG5cbmludGVyZmFjZSBUb2tlbkVtaXR0ZXI8ViwgVCwgQz4ge1xuICBlbWl0KCk6IHZvaWQ7XG4gIGVuZCgpOiB2b2lkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VyPFYsIFQsIEMgZXh0ZW5kcyBDaHVuazxWLCBUPiwgQT4ocGFyc2VyTmFtZTogc3RyaW5nLFxuICBsZXhlcjogTGV4ZXI8ViwgVCwgQz4sXG4gIGdyYW1tYXI6IEdyYW1tYXI8QywgQT4sXG4gIGNodW5rQ29udmVydGVyPzogKGNodW5rOiBDaHVuazxWLCBUPikgPT4gQyk6XG4gIHtcbiAgICB3cml0ZTogTG9va0FoZWFkPFYsIFQ+Wydfd3JpdGUnXTtcbiAgICBlbmQ6IExvb2tBaGVhZDxWLCBUPlsnX2ZpbmFsJ107XG4gICAgZ2V0UmVzdWx0OiAoKSA9PiBBO1xuICB9IHtcblxuICBsZXQgaXNTdHJpbmc6IGJvb2xlYW47XG4gIGNvbnN0IGxleGVyTGEgPSBuZXcgTG9va0FoZWFkPFYsIFQ+KHBhcnNlck5hbWUgKyAnIGxleGVyJyk7XG4gIGNvbnN0IHRva2VuRW1pdHRlcjogVG9rZW5FbWl0dGVyPFYsIFQsIEM+ID0ge1xuICAgIGVtaXQoKSB7XG4gICAgICBpZiAoaXNTdHJpbmcgPT09IHVuZGVmaW5lZCAmJiBsZXhlckxhLmN1cnJDaHVuay52YWx1ZXMgIT0gbnVsbClcbiAgICAgICAgaXNTdHJpbmcgPSB0eXBlb2YgbGV4ZXJMYS5jdXJyQ2h1bmsudmFsdWVzWzBdID09PSAnc3RyaW5nJztcbiAgICAgIGNvbnN0IHRva2VuOiBDID0gY2h1bmtDb252ZXJ0ZXIgPyBjaHVua0NvbnZlcnRlcihsZXhlckxhLmN1cnJDaHVuaykgOlxuICAgICAgICAoaXNTdHJpbmcgP1xuICAgICAgICAgIHN0ckNodW5rMlRva2VuKGxleGVyTGEuY3VyckNodW5rIGFzIHVua25vd24gYXMgQ2h1bms8c3RyaW5nLCBUPikgYXMgdW5rbm93biBhcyBDIDpcbiAgICAgICAgICBsZXhlckxhLmN1cnJDaHVuayBhcyBDKTtcbiAgICAgIHRva2VuTGEuX3dyaXRlKFt0b2tlbl0pO1xuICAgICAgdG9rZW4uY2xvc2UobGV4ZXJMYS5wb3NpdGlvbik7XG4gICAgfSxcbiAgICBlbmQoKSB7XG4gICAgICB0b2tlbkxhLl9maW5hbCgpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdG9rZW5MYSA9IG5ldyBMb29rQWhlYWQ8Qz4ocGFyc2VyTmFtZSArICcgZ3JhbW1hcicsIGZ1bmN0aW9uKCkge1xuICAgIGxleGVyKGxleGVyTGEsIHRva2VuRW1pdHRlcik7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHdyaXRlOiBsZXhlckxhLl93cml0ZS5iaW5kKGxleGVyTGEpIGFzIExvb2tBaGVhZDxWLCBUPlsnX3dyaXRlJ10sXG4gICAgZW5kOiBsZXhlckxhLl9maW5hbC5iaW5kKGxleGVyTGEpIGFzIExvb2tBaGVhZDxWLCBUPlsnX2ZpbmFsJ10sXG4gICAgZ2V0UmVzdWx0KCkge1xuICAgICAgcmV0dXJuIGdyYW1tYXIodG9rZW5MYSk7XG4gICAgfVxuICB9O1xufVxuXG5cbmV4cG9ydCBjbGFzcyBMb29rQWhlYWQ8ViwgVCA9IHZvaWQ+IHtcbiAgc3RhdGljIFdBSVRfRVJST1I6ICdXQUlUX0VSUk9SJztcbiAgY2FjaGVkOiBBcnJheTxWIHwgbnVsbD47XG4gIGxpbmUgPSAxO1xuICBjb2x1bW4gPSAxO1xuICBsYXN0Q29uc3VtZWQ6IFY7XG4gIGN1cnJDaHVuazogQ2h1bms8ViwgVD47XG5cbiAgcHJpdmF0ZSBjdXJyUG9zID0gMDtcbiAgcHJpdmF0ZSBjYWNoZVN0YXJ0UG9zID0gMDtcblxuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgbmFtZTogc3RyaW5nLCBwcml2YXRlIG9uRHJhaW4/OiAodGhpczogTG9va0FoZWFkPFYsIFQ+KSA9PiB2b2lkKSB7XG4gICAgdGhpcy5jYWNoZWQgPSBbXTtcbiAgfVxuXG4gIF93cml0ZSh2YWx1ZXM6IEl0ZXJhYmxlPFYgfCBudWxsPikge1xuICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZXMpXG4gICAgICB0aGlzLmNhY2hlZC5wdXNoKHYpO1xuICB9XG5cbiAgX2ZpbmFsKCkge1xuICAgIHRoaXMuX3dyaXRlKFtudWxsXSk7XG4gIH1cblxuICBnZXQgcG9zaXRpb24oKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyUG9zO1xuICB9XG5cbiAgLyoqXG5cdCAqIGxvb2sgYWhlYWQgZm9yIDEgY2hhcmFjdGVyXG5cdCAqIEBwYXJhbSBudW0gZGVmYXVsdCBpcyAxXG5cdCAqIEByZXR1cm4gbnVsbCBpZiBFT0YgaXMgcmVhY2hlZFxuXHQgKi9cbiAgbGEobnVtID0gMSk6IFYgfCBudWxsIHtcbiAgICBjb25zdCByZWFkUG9zID0gdGhpcy5jdXJyUG9zICsgbnVtIC0gMTtcbiAgICByZXR1cm4gdGhpcy5yZWFkKHJlYWRQb3MpO1xuICB9XG5cbiAgYWR2YW5jZShjb3VudCA9IDEpOiBWIHtcbiAgICAvLyByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgbGV0IGN1cnJWYWx1ZTogVjtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkrKyA8IGNvdW50KSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMubGEoMSk7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnRocm93RXJyb3IoJ1VuZXhwZWN0IEVPRicpOyAvLyAsIHN0YWNrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0aGlzLmN1cnJQb3MrKztcbiAgICAgIHRoaXMuY29sdW1uKys7XG4gICAgICBpZiAoKHZhbHVlIGFzIGFueSkgPT09ICdcXG4nKSB7XG4gICAgICAgIHRoaXMubGluZSsrO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IDE7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jdXJyUG9zIC0gdGhpcy5jYWNoZVN0YXJ0UG9zID4gMHgxMDAwMDApIHtcbiAgICAgICAgdGhpcy5jYWNoZWQuc3BsaWNlKDAsIDB4MTAwMDAwKTtcbiAgICAgICAgdGhpcy5jYWNoZVN0YXJ0UG9zICs9IDB4MTAwMDAwO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY3VyckNodW5rICYmICF0aGlzLmN1cnJDaHVuay5pc0Nsb3NlZCAmJiB0aGlzLmN1cnJDaHVuay50cmFja1ZhbHVlKSB7XG4gICAgICAgIHRoaXMuY3VyckNodW5rLnZhbHVlcyEucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBjdXJyVmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgdGhpcy5sYXN0Q29uc3VtZWQgPSBjdXJyVmFsdWUhO1xuICAgIHJldHVybiBjdXJyVmFsdWUhO1xuICB9XG5cbiAgaXNOZXh0KC4uLnZhbHVlczogVltdKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNOZXh0V2l0aCh2YWx1ZXMpO1xuICB9XG4gIC8qKlxuXHQgKiBTYW1lIGFzIGByZXR1cm4gbGEoMSkgPT09IHZhbHVlc1swXSAmJiBsYSgyKSA9PT0gdmFsdWVzWzFdLi4uYFxuXHQgKiBAcGFyYW0gdmFsdWVzIGxvb2thaGVhZCBzdHJpbmcgb3IgdG9rZW5zXG5cdCAqL1xuICBpc05leHRXaXRoPEM+KHZhbHVlczogQ1tdLCBpc0VxdWFsID0gKGE6IFYsIGI6IEMpID0+IGEgYXMgYW55ID09PSBiKTogYm9vbGVhbiB7XG4gICAgbGV0IGNvbXBhcmVUbzogQ1tdIHwgc3RyaW5nO1xuICAgIGxldCBjb21wYXJlRm46ICguLi5hcmc6IGFueVtdKSA9PiBib29sZWFuO1xuICAgIGNvbXBhcmVUbyA9IHZhbHVlcztcbiAgICBjb21wYXJlRm4gPSBpc0VxdWFsO1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCBsID0gY29tcGFyZVRvLmxlbmd0aDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGkgPT09IGwpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY29uc3QgbmV4dCA9IHRoaXMubGEoaSArIDEpO1xuICAgICAgaWYgKG5leHQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBFT0ZcbiAgICAgIGVsc2UgaWYgKCFjb21wYXJlRm4obmV4dCwgY29tcGFyZVRvW2ldKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuXG4gIGFzc2VydEFkdmFuY2UoLi4udmFsdWVzOiBWW10pIHtcbiAgICByZXR1cm4gdGhpcy5hc3NlcnRBZHZhbmNlV2l0aCh2YWx1ZXMpO1xuICB9XG5cbiAgYXNzZXJ0QWR2YW5jZVdpdGg8Qz4odmFsdWVzOiBDW10sIGlzRXF1YWwgPSAoYTogViwgYjogQykgPT4gYSBhcyBhbnkgPT09IGIpIHtcbiAgICBsZXQgY29tcGFyZVRvOiBDW10gfCBzdHJpbmc7XG4gICAgbGV0IGNvbXBhcmVGbjogKC4uLmFyZzogYW55W10pID0+IGJvb2xlYW47XG4gICAgY29tcGFyZVRvID0gdmFsdWVzO1xuICAgIGNvbXBhcmVGbiA9IGlzRXF1YWw7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IGwgPSBjb21wYXJlVG8ubGVuZ3RoO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoaSA9PT0gbClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjb25zdCBuZXh0ID0gdGhpcy5hZHZhbmNlKGkgKyAxKTtcbiAgICAgIGlmIChuZXh0ID09IG51bGwpXG4gICAgICAgIHRoaXMudGhyb3dFcnJvcignRU9GJywgbmV3IEVycm9yKCkuc3RhY2spOyAvLyBFT0ZcbiAgICAgIGVsc2UgaWYgKCFjb21wYXJlRm4obmV4dCwgY29tcGFyZVRvW2ldKSlcbiAgICAgICAgdGhpcy50aHJvd0Vycm9yKHV0aWwuaW5zcGVjdChuZXh0KSwgbmV3IEVycm9yKCkuc3RhY2ssIGNvbXBhcmVUb1tpXSArICcnKTtcbiAgICAgIGkrKztcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHVuZXhwZWN0ZWQgPSAnRW5kLW9mLXN0cmVhbScsIHN0YWNrPzogYW55LCBleHBlY3Q/OiBzdHJpbmcpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgIHRocm93IG5ldyBFcnJvcihgSW4gJHt0aGlzLm5hbWV9IHVuZXhwZWN0ZWQgJHtKU09OLnN0cmluZ2lmeSh1bmV4cGVjdGVkKX1gICtcbiAgICAoZXhwZWN0ID8gYChleHBlY3RpbmcgXCIke2V4cGVjdH1cIilgIDogJycpICtcbiAgICBgYXQgJHt0aGlzLmdldEN1cnJlbnRQb3NJbmZvKCl9LCAke3N0YWNrID8gJ3ByZXZpb3VzIHN0YWNrOicgKyBzdGFjayA6ICcnfWApO1xuICB9XG5cbiAgZ2V0Q3VycmVudFBvc0luZm8oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYG9mZnNldCAke3RoaXMuY3VyclBvc30gWyR7dGhpcy5saW5lfToke3RoaXMuY29sdW1ufV1gO1xuICB9XG5cbiAgc3RhcnRDaHVuayh0eXBlOiBULCB0cmFja1ZhbHVlID0gdHJ1ZSkge1xuICAgIGlmICh0aGlzLmN1cnJDaHVuayAmJiAhdGhpcy5jdXJyQ2h1bmsuaXNDbG9zZWQpXG4gICAgICB0aGlzLmN1cnJDaHVuay5jbG9zZSh0aGlzLmN1cnJQb3MpO1xuICAgIHRoaXMuY3VyckNodW5rID0gbmV3IENodW5rPFYsIFQ+KHRoaXMuY3VyclBvcywgdGhpcy5saW5lLCB0aGlzLmNvbHVtbik7XG4gICAgdGhpcy5jdXJyQ2h1bmsudHJhY2tWYWx1ZSA9IHRyYWNrVmFsdWU7XG4gICAgdGhpcy5jdXJyQ2h1bmsudHlwZSA9IHR5cGU7XG4gICAgcmV0dXJuIHRoaXMuY3VyckNodW5rO1xuICB9XG5cbiAgcHJvdGVjdGVkIGNsb3NlQ2h1bmsoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VyckNodW5rLmNsb3NlKHRoaXMuY3VyclBvcyk7XG4gIH1cblxuICAvKipcblx0ICogRG8gbm90IHJlYWQgcG9zdGlvbiBsZXNzIHRoYW4gMFxuXHQgKiBAcGFyYW0gcG9zIFxuXHQgKi9cbiAgcHJpdmF0ZSByZWFkKHBvczogbnVtYmVyKTogViB8IG51bGwge1xuICAgIGNvbnN0IGNhY2hlT2Zmc2V0ID0gcG9zIC0gdGhpcy5jYWNoZVN0YXJ0UG9zO1xuICAgIGlmIChjYWNoZU9mZnNldCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuIG5vdCByZWFkIGJlaGluZCBzdHJlYW0gY2FjaGUsIGF0IHBvc2l0aW9uOiAke3Bvc31gKTtcbiAgICB9XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChjYWNoZU9mZnNldCA8IHRoaXMuY2FjaGVkLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZWRbY2FjaGVPZmZzZXRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMub25EcmFpbikge1xuICAgICAgICAgIHRoaXMub25EcmFpbigpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGludGVybmFsIGJ1ZmZlciBpcyBkcmFpbmVkIGVhcmx5IGF0ICR7cG9zfWApO1xuICAgICAgICAvLyB0aGlzLndhaXRGb3JQb3MgPSBwb3M7XG4gICAgICAgIC8vIGNvbnN0IGVyciA9IG5ldyBXYWl0RXJyb3IoKTtcbiAgICAgICAgLy8gdGhyb3cgZXJyO1xuICAgICAgICAvLyByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIC8vICAgdGhpcy5yZWFkUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIC8vIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdHJDaHVuazJUb2tlbjxUPihjaHVuazogQ2h1bms8c3RyaW5nLCBUPikge1xuICBpZiAoY2h1bmsudmFsdWVzKSB7XG4gICAgKGNodW5rIGFzIFRva2VuPFQ+KS50ZXh0ID0gY2h1bmsudmFsdWVzLmpvaW4oJycpO1xuICAgIGRlbGV0ZSBjaHVuay52YWx1ZXM7XG4gIH1cbiAgcmV0dXJuIGNodW5rIGFzIFRva2VuPFQ+O1xufVxuXG4vKipcbiAqIENvbnZlbmllbnQgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgdGV4dCBiYXNlZCBwYXJzZXIsXG4gKiB5b3Ugb25seSBuZWVkIHRvIGRlZmluZSBUb2tlbiB0eXBlcywgbGV4ZXIgZnVuY3Rpb24sIGdyYW1tYXIgZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRleHRQYXJzZXIoKSB7XG5cbn1cbiJdfQ==