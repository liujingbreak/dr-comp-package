#!/usr/bin/env node
import fs from 'fs';
import {CliExtension, GlobalOptions} from '@wfh/plink/wfh/dist/cmd/types';
import replacePatches, { ReplacementInf } from '@wfh/plink/wfh/dist/utils/patch-text';
import Path from 'path';
import commander from 'Commander';
import {saveCmdOptionsToEnv} from '../utils';
import {initConfigAsync} from '@wfh/plink/wfh/dist';
import walkPackagesAndSetupInjector from '@wfh/webpack-common/dist/initInjectors';
import log4js from 'log4js';
import {ObjectAst} from '@wfh/plink/wfh/dist/utils/json-sync-parser';


const cli: CliExtension = (program, withGlobalOptions) => {

  const genCmd = program.command('cra-gen <dir>')
  .description('Generate a sample package in specific directory')
  .option('-d, --dry-run', 'Do not generate files, just list new file names', false)
  .action(async (dir: string) => {
    (await import('./cli-gen')).genPackage(dir, genCmd.opts().dryRun);
  });

  const buildCmd = program.command('cra-build <app|lib> <package-name>')
  .description('Compile react application or library, <package-name> is the target package name')
  .action(async (type, pkgName) => {
    await initEverything(buildCmd, type, pkgName);
    require('react-scripts/scripts/build');
  });
  withClicOpt(buildCmd);
  withGlobalOptions(buildCmd);



  const initCmd = program.command('cra-init')
  .description('Initial workspace files based on files which are newly generated by create-react-app')
  .action(async () => {
    await initConfigAsync(initCmd.opts() as GlobalOptions);
    const log = log4js.getLogger('cra');
    const {default: parse} = await import('@wfh/plink/wfh/dist/utils/json-sync-parser');
    let fileContent = fs.readFileSync('tsconfig.json', 'utf8');
    const ast = parse(fileContent);
    let pMap = new Map(ast.properties.map(el => [/^"(.*)"$/.exec(el.name.text)![1], el]));
    const replacements: ReplacementInf[] = [];
    if (pMap.has('extends')) {
      // tslint:disable-next-line: no-console
      console.log('there is a "extends" in tsconfig.json, skip it');
    } else {
      const baseTsConfig = Path.relative(process.cwd(), require.resolve('@wfh/plink/wfh/tsconfig-base.json')).replace(/\\/g, '/');
      replacements.push({start: 1, end: 1, replacement: `\n  "extends": "${baseTsConfig}",`});
    }
    // log.warn(Array.from(pMap.keys()));
    const coAst = pMap.get('compilerOptions')!.value as ObjectAst;
    const rootDir = coAst.properties.find(prop => prop.name.text === '"rootDir"');
    if (rootDir == null) {
      replacements.push({start: coAst.start + 1, end: coAst.start + 1,
        replacement: '\n    "rootDir": ".",'});
    }
    if (replacements.length > 0) {
      fileContent = replacePatches(fileContent, replacements);
      fs.writeFileSync('tsconfig.json', fileContent);
      log.info('tsconfig.json is updated.');
    }
  });
  withGlobalOptions(initCmd);
};

function withClicOpt(cmd: commander.Command) {
  cmd.option('-w, --watch', 'Watch file changes and compile', false)
  .option('--dev', 'set NODE_ENV to "development", enable react-scripts in dev mode', false)
  .option('--purl, --publicUrl <string>', 'set environment variable PUBLIC_URL for react-scripts', '/');
}

async function initEverything(buildCmd: commander.Command, type: 'app' | 'lib', pkgName: string) {
  await initConfigAsync(buildCmd.opts() as GlobalOptions);
  await walkPackagesAndSetupInjector(process.env.PUBLIC_URL || '/');
  if (!['app', 'lib'].includes(type)) {
    const log = log4js.getLogger('cra');
    log.error(`type argument must be one of "${['app', 'lib']}"`);
    return;
  }
  saveCmdOptionsToEnv(pkgName, buildCmd, type);
  await (await import('../preload')).poo();
}

export {cli as default};

